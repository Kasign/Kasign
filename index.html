<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-开发中手势方法的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-开发中手势方法的使用/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-开发中手势方法的使用/">iOS-开发中手势方法的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>以下使用方法能够较好的控制手势</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)pinchGestureDetected:(UIPinchGestureRecognizer *)recognizer  </span><br><span class="line">&#123;  </span><br><span class="line">    UIGestureRecognizerState state = [recognizer state];  </span><br><span class="line">      if (state == UIGestureRecognizerStateBegan || state == UIGestureRecognizerStateChanged)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CGFloat scale = [recognizer scale];  </span><br><span class="line">        [recognizer.view setTransform:CGAffineTransformScale(recognizer.view.transform, scale, scale)];  </span><br><span class="line">        [recognizer setScale:1.0];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)rotationGestureDetected:(UIRotationGestureRecognizer *)recognizer  </span><br><span class="line">&#123;  </span><br><span class="line">    UIGestureRecognizerState state = [recognizer state];  </span><br><span class="line">      </span><br><span class="line">    if (state == UIGestureRecognizerStateBegan || state == UIGestureRecognizerStateChanged)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CGFloat rotation = [recognizer rotation];  </span><br><span class="line">        [recognizer.view setTransform:CGAffineTransformRotate(recognizer.view.transform, rotation)];  </span><br><span class="line">        [recognizer setRotation:0];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)panGestureDetected:(UIPanGestureRecognizer *)recognizer  </span><br><span class="line">&#123;  </span><br><span class="line">    UIGestureRecognizerState state = [recognizer state];  </span><br><span class="line">      </span><br><span class="line">    if (state == UIGestureRecognizerStateBegan || state == UIGestureRecognizerStateChanged)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CGPoint translation = [recognizer translationInView:recognizer.view];  </span><br><span class="line">        [recognizer.view setTransform:CGAffineTransformTranslate(recognizer.view.transform, translation.x, translation.y)];  </span><br><span class="line">        [recognizer setTranslation:CGPointZero inView:recognizer.view];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-开发中手势方法的使用/" data-id="cjgdiqq6z000akezi7w38zen7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-C指针--函数形参int-p与int--p的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/C指针--函数形参int-p与int--p的区别/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/C指针--函数形参int-p与int--p的区别/">C指针--函数形参int-p与int--p的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void fun(int * p) ;</span><br><span class="line">int * pBuf = NULL;                                    //****************(1)</span><br><span class="line">fun(pBuf);                                            //****************(2)</span><br><span class="line">void fun(int * p)                                     //****************(3)</span><br><span class="line">&#123;</span><br><span class="line">      p = (int*)malloc(10*sizeof(int));               //****************(4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面分析一下在每行代码中都发生了什么：</p>
<p> 在  (1) 中，声明pBuf为int *类型，指向int类型。此时，pBuf 是指针，其是有值的，即有内存地址(假如是：0x00007fff5fbff620)，但其指向的内存却为空NULL。</p>
<p>在 (2)  (3)中，pBuf 作为实参传入函数 fun(int <em> p) 中(p为形参，此时p为int </em> 类型，指向int类型)。p =pBuf，亦为0x00007fff5fbff620，具有相同地址。</p>
<p>在 (4) 中，malloc申请一块内存，并返回指向此内存的地址，并给了p，此时 p 指向了malloc申请的内存，p有了新的地址，与pBuf不再相等，不再为0x00007fff5fbff620。而此时pBuf却没有改变，依然是0x00007fff5fbff620。</p>
<p>所有这种方法并不会为pBuf改变什么，仍然指向NULL。但是pBuf是有内存地址的(初始化的时候就有),却指向NULL，即并没有开辟内存，所有不能对pBuf进行赋值，因为其没有内存存储值。</p>
<p>再看另一种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void fun(int ** p) ;</span><br><span class="line">int * pBuf = NULL;                                     //****************(1)</span><br><span class="line">fun(&amp;pBuf);                                            //****************(2)</span><br><span class="line">void fun(int ** p)                                     //****************(3)</span><br><span class="line">&#123;</span><br><span class="line">      *p = (int*)malloc(10*sizeof(int));               //****************(4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的分析一下上面每行代码中都发生了什么：</p>
<p> 在  (1) 中，与第一段代码没什么区别。假如：pBuf = 0x00007fff5fbff620，&amp;pBuf=0x00007fffaaae0f70，* pBuf = NULL。</p>
<p>在 (2)  (3)中，&amp;pBuf作为实参传入函数fun(int <strong> p)中(p为形参，此时p为int</strong> 类型，即为指针的指针)，p=&amp;pBuf(0x00007fffaaae0f70)。指向 int<em> 类型，即指向了指针，这个指针其实就是pBuf，即 p 指向了 pBuf ，所以  </em> p其实就是 pBuf (0x00007fff5fbff620)。此时别忘记，0x00007fff5fbff620 是指向NULL的。</p>
<p>在 (4) 中，malloc申请一块内存，并返回指向此内存的地址，并给了 <em>p，此时 </em>p 指向了malloc申请的内存。此时 p依然没有改变，与&amp;pBuf相等(0x00007fffaaae0f70)，但是p指向的地址却改变了，指向了一块新的内存。所以0x00007fffaaae0f70指向的一个新的内存地址，而这个内存地址也指向的一块内存，不再是NULL。</p>
<p>总结：<br>第一段代码，传入了指向空内存的地址，最后改变了形参p的地址，与传入的pBuf不再相等，所有没有对pBuf进行改变什么。<br>第二段代码，传入了指向指针pBuf的指针，最后改变的是p指向的地址，而p依然是指向指针pBuf的指针。最后其实是改变了传入的指针的指向，即改变了&amp;pBuf的指向，让其指向了新的地址。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/C指针--函数形参int-p与int--p的区别/" data-id="cjgdiqq6n0000kezisheozvoq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-KVO键值依赖" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/KVO键值依赖/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/KVO键值依赖/">KVO键值依赖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一个属性与有限个属性关联，例如下面的totalAge与user1和user2的age息息相关，只要其中一个改变，totalAge就会改变。"><a href="#一个属性与有限个属性关联，例如下面的totalAge与user1和user2的age息息相关，只要其中一个改变，totalAge就会改变。" class="headerlink" title="一个属性与有限个属性关联，例如下面的totalAge与user1和user2的age息息相关，只要其中一个改变，totalAge就会改变。"></a>一个属性与有限个属性关联，例如下面的totalAge与user1和user2的age息息相关，只要其中一个改变，totalAge就会改变。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Person.h</span><br><span class="line">//</span><br><span class="line">//  Created by Walg on 2017/7/29.</span><br><span class="line">//  Copyright © 2017年 Walg. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,copy)NSString *pName;</span><br><span class="line">@property (nonatomic,assign)NSInteger age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Person.m中未做任何处理！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Card.h</span><br><span class="line">//</span><br><span class="line">//  Created by Walg on 2017/7/29.</span><br><span class="line">//  Copyright © 2017年 Walg. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@interface Card : NSObject</span><br><span class="line">@property (nonatomic,assign)NSInteger totalAge;</span><br><span class="line">@property (nonatomic,strong)Person *user1;</span><br><span class="line">@property (nonatomic,strong)Person *user2;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  Card.m</span><br><span class="line">//</span><br><span class="line">//  Created by Walg on 2017/7/29.</span><br><span class="line">//  Copyright © 2017年 Walg. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Card</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _user1 = [[Person alloc] init];</span><br><span class="line">        _user2 = [[Person alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSInteger)totalAge&#123;</span><br><span class="line">    return _user1.age+_user2.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    NSArray *moreKeyPaths = nil;</span><br><span class="line">    if ([key isEqualToString:@&quot;totalAge&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        moreKeyPaths = [NSArray arrayWithObjects:@&quot;user1.age&quot;, @&quot;user2.age&quot;, nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (moreKeyPaths)</span><br><span class="line">    &#123;</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:moreKeyPaths];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>使用：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  键值依赖</span><br><span class="line">//</span><br><span class="line">//  Created by Walg on 2017/7/30.</span><br><span class="line">//  Copyright © 2017年 Walg. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Card.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)Card *userCard;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSInteger NewAge()&#123;</span><br><span class="line">    static NSInteger newAge = 10;</span><br><span class="line">    return newAge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _userCard = [[Card alloc] init];</span><br><span class="line">    _userCard.user1.pName = @&quot;a&quot;;</span><br><span class="line">    _userCard.user1.age = 18;</span><br><span class="line">    </span><br><span class="line">    [self.userCard addObserver:self forKeyPath:@&quot;totalAge&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;keyPath:%@&quot;,keyPath);</span><br><span class="line">    NSLog(@&quot;object:%@&quot;,object);</span><br><span class="line">    NSLog(@&quot;change:%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.userCard.user2.age = NewAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>log：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2017-07-30 14:14:07.100 键值依赖[62587:1948971] keyPath:totalAge</span><br><span class="line">2017-07-30 14:14:07.101 键值依赖[62587:1948971] object:&lt;Card: 0x60800003dfa0&gt;</span><br><span class="line">2017-07-30 14:14:07.101 键值依赖[62587:1948971] change:&#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 28;</span><br><span class="line">    old = 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/KVO键值依赖/" data-id="cjgdiqq6t0002kezixfbff4nw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发过程中遇到的新奇玩意儿" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS开发过程中遇到的新奇玩意儿/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS开发过程中遇到的新奇玩意儿/">iOS开发过程中遇到的新奇玩意儿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>持续更新中。。。另一篇&lt;[iOS 总结遇到的各种坑儿]&gt;</p>
<p>##一、集合返回枚举对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (NSEnumerator *)keyEnumerator &#123;</span><br><span class="line">    </span><br><span class="line">    return [array objectEnumerator];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSEnumerator *)reverseKeyEnumerator &#123;</span><br><span class="line">    </span><br><span class="line">    return [array reverseObjectEnumerator];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的NSEnumerator ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">官方解释：</span><br><span class="line">NSEnumerator</span><br><span class="line"> is an abstract class, instances of whose subclasses enumerate collections of other objects, such as arrays and dictionaries.</span><br><span class="line">All creation methods are defined in the collection classes—such as NSArray</span><br><span class="line">, NSSet</span><br><span class="line">, and NSDictionary</span><br><span class="line">—which provide special NSEnumerator</span><br><span class="line"> objects with which to enumerate their contents. For example, NSArray</span><br><span class="line"> has two methods that return an NSEnumerator</span><br><span class="line">object: [objectEnumerator](apple-reference-documentation://hcQ1W7GHf_) and [reverseObjectEnumerator](apple-reference-documentation://hc41c-0oVQ). NSDictionary</span><br><span class="line">also has two methods that return an NSEnumerator</span><br><span class="line"> object: [keyEnumerator](apple-reference-documentation://hc-hIDsaE8) and [objectEnumerator](apple-reference-documentation://hc7rb-nJ5L). These methods let you enumerate the contents of a dictionary by key or by value, respectively.</span><br><span class="line">You send [nextObject](apple-reference-documentation://hcp9Mbgcbv) repeatedly to a newly created NSEnumerator</span><br><span class="line">object to have it return the next object in the original collection. When the collection is exhausted, nil</span><br><span class="line"> is returned. You cannot “reset” an enumerator after it has exhausted its collection. To enumerate a collection again, you need a new enumerator.</span><br><span class="line">The enumerator subclasses used by NSArray</span><br><span class="line">, NSDictionary</span><br><span class="line">, and NSSet</span><br><span class="line"> retain the collection during enumeration. When the enumeration is exhausted, the collection is released.</span><br><span class="line">**Note**In Objective-C, it is not safe to modify a mutable collection while enumerating through it. Some enumerators may currently allow enumeration of a collection that is modified, but this behavior is not guaranteed to be supported in the future.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">官方解释译文：</span><br><span class="line">NSEnumerator是一个抽象类，其子类枚举其他对象（如数组和字典）的集合的实例。</span><br><span class="line">所有创建方法都在集合类中定义，例如NSArray，NSSet和NSDictionary，它们提供用于枚举其内容的特殊NSEnumerator对象。例如，NSArray有两个返回NSEnumerator对象的方法：objectEnumerator和reverseObjectEnumerator。 NSDictionary还有两个返回NSEnumerator对象的方法：keyEnumerator和objectEnumerator。这些方法可以分别按键或值枚举字典的内容。</span><br><span class="line">您将nextObject重复发送到新创建的NSEnumerator对象，以使其返回原始集合中的下一个对象。收集用尽时，返回零。枚举器耗尽其收集后，您无法“重置”。要再次枚举一个集合，您需要一个新的枚举器。</span><br><span class="line">NSArray，NSDictionary和NSSet使用的枚举子子类在枚举期间保留集合。枚举耗尽时，集合被释放。</span><br><span class="line">注意</span><br><span class="line">在Objective-C中，通过枚举来修改可变集合是不安全的。一些枚举者可能现在允许枚举一个被修改的集合，但这种行为不能保证在将来被支持。</span><br></pre></td></tr></table></figure>
<p>##二、ios字体<br>ios9以上 默认字体是 苹方字体<br>ios8 默认字体是 常州华文的Heiti SC。</p>
<p>##三、报黄提醒</p>
<p>#define FLYRefreshDeprecated(instead) NS_DEPRECATED(2_0, 2_0, 2_0, 2_0, instead)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS开发过程中遇到的新奇玩意儿/" data-id="cjgdiqq77000jkeziwfqv9slr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发证书要点详解，ios证书详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS开发证书要点详解，ios证书详解/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS开发证书要点详解，ios证书详解/">iOS开发证书要点详解，ios证书详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于开发证书配置（Certificates&amp;Identifiers&amp;Provisioning Profiles），相信做iOS开发的同学没少被折腾。对于一个iOS开发小白、半吊子抑或老兵，或多或少会有以下不详、疑问、疑惑甚至困惑：</p>
<p>本文将对相关概念做个系统的梳理串烧。</p>
<p>首先，假设你使用过Apple设备（iMac/iPad/iPhone）且注册过Apple ID（Apple Account）。<br>其次，你必须加入苹果开发者计划（Enroll in iOS Developer Program to become a member），注册一个开发者账号。<br>只有拥有开发者账号，才可以申请开发/发布证书及相关配置授权文件，进而在iOS真机上开发调试Apps或发布到App Store。<br>开发者账号分为Individual和Company/Organization两种类型。如无特别交代，下文基于$99/Year的普通个人开发者（Individual）账号展开。</p>
<p>####一.App ID（bundle identifier）<br>App ID用于标识一个或者一组App，App ID应该和Xcode中的Bundle Identifier是一致的或匹配的。<br>App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed）。<br>App ID全名会被追加ApplicationIdentifierPrefix（一般为TeamID.），分为两类：<br>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的程序。<br>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如“<em>”（实际上是ApplicationIdentifierPrefix）表示所有应用程序；而“com.apple.</em>”可以表示以“com.apple.”开头的所有应用程序。</p>
<p>用户可在网站上删除（Delete）已注册的App IDs。App ID<strong>被配置到</strong>【XcodeTarget|Info|Bundle Identifier】下；对于Wildcard App ID，只要bundle identifier包含其作为Prefix/Seed即可。</p>
<p>####二.设备（Device）<br>Device就是运行iOS系统用于开发调试App的设备，每台设备使用<strong>UDID</strong>来唯一标识。iOS设备连接Mac后，可通过iTunes-&gt;Summary或者Xcode-&gt;Window-&gt;Devices获取iPhone的UDID（identifier）。<br>Apple Member Center网站个人账号下的Devices中包含了注册过的所有可用于开发和<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>的设备。普通个人开发账号每年累计最多只能注册100个设备，用户可在网站上启用/禁用（Enable/Disable）已注册的Device。<br>Apps signed by you or your team run only on designated development devices.<br>Apps run only on the test devices you specify.</p>
<p>本文的Devices即<strong>连接到</strong>Xcode被授权用于开发测试的iOS设备（iPhone/iPad）。</p>
<p>####三.证书（Certificates）<br>顾名思义，证书是用来证明内容（App的executalbe code）的合法性和完整性的。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证App内容是完整、未经篡改的。<br>证书分为两类：Development和Production（Distribution）。<br>Development证书用来开发和调试应用程序：A <strong><em>development certificate</em></strong> identifies you, as a team member, in a development provisioning profile that allows apps signed by you to <strong><em>launch </em></strong>on devices.<br>Production主要用来分发应用程序（根据证书种类有不同作用）：A <strong><em>distribution certificate</em></strong> identifies your team or organization in a distribution provisioning profile and allows you to <strong><em>submit  </em></strong>your app to the store. Only a team agent or an admin can create a distribution certificate.</p>
<p>普通个人开发账号最多可注册iOS Development/Distribution证书各2个，用户可在网站上删除（Revoke）已注册的Certificate。下文主要针对开发调试阶段的Development证书。<br>首先，iOS以及Mac OS X系统（在安装Xcode时）将自动安装AppleWWDRCA.cer<em>(Apple Worldwide Developer Relations Certification Authority)</em>这个中间证书（<strong>Intermediate Certificates）</strong>。它实际上就是iOS证书的CA，其公钥用于解密认证证书的可靠性。如果Mac Keychain Access证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-6915aad5088cce83?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>通过Keychain证书助理<strong>手动申请</strong>开发证书时（也可通过Xcode自动请求生成），keychain将生成一个包含开发者身份信息的<strong>CSR</strong>（Certificate Signing Request）文件；同时，Keychain Access|Keys中将新增一对Public/Private <strong>Key Pair</strong>（This signing identity consists of a public-private key pair that Apple issues）。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-51018fcd34ca6844?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>private key用于签名（CodeSign），始终保存在Mac OS的Keychain Access中；public key一般随证书散布出去，对签名进行校验认证。用户必须保护好本地Keychain中的private key，以防伪冒。<br>Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an <strong><em>entirely new</em></strong> identity to sign code.<br>Worse, if someone else has your private key, that person may be able to <strong><em>impersonate </em></strong>you.</p>
<p>在Apple开发网站上传该CSR文件，Apple证书颁发机构WWDRCA将使用private key对CSR中的public key和一些身份信息进行加密签名生成<strong>数字证书</strong>（ios_development.cer）并记录在案（Apple Member Center）。<br>从Apple Member Center网站下载证书到Mac上双击即可安装。证书安装成功后，在KeychainAccess|Keys中展开创建CSR时生成的Key Pair中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在Keychain Access|Certificates中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-43443ba9168bb1eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2647951-45d5cd4089552153?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Certificate<strong>被配置到</strong>【Xcode Target|Build Settings|Code Signing|Code Signing Identity】下，下拉选择Identities from Profile “…”（一般先配置Provisioning Profile）。</p>
<p>####四.供应配置文件（Provisioning Profiles）<br><strong>Provisioning Profile文件包含了上述的所有内容：</strong>证书、App ID和设备**。<br>一个Provisioning Profile对应一个Explicit App ID或Wildcard App ID（一组相同Prefix/Seed的App IDs）。在网站上手动创建一个Provisioning Profile时，需要依次指定App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的ProvisioningProfiles。<br>Provisioning Profile决定Xcode用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product）,将在应用程序打包时嵌入到.ipa包里。安装应用程序时，Provisioning Profile文件被拷贝到iOS设备中，运行该iOS App的设备也通过它来认证安装的程序。<br>如果要打包或者在真机上运行一个APP，一般要经历以下三步：<br>首先，需要证书对应的私钥来进行签名，用于标识这个APP是合法、安全、完整的；<br>其次，需要指明它的App ID，并且验证Bundle ID是否与其一致；<br>然后，如果是真机调试，需要确认这台设备是否授权运行该APP。</p>
<p>Provisioning Profile把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的Provisioning Profile文件就可以了。<br>Provisioning Profile也分为Development和Distribution两类，有效期同Certificate一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited）。App ID为Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。</p>
<p>Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录~/Library/MobileDevice/Provisioning Profiles下。<br>以下为典型供应配置文件*.mobileprovision的<strong>构成简析</strong>：</p>
<p>（1）<strong><em>Name</em></strong>：该mobileprovision的文件名。</p>
<p>（2）<strong><em>UUID</em></strong>：该mobileprovision文件的真实文件名。</p>
<p>（3）<strong><em>TeamName</em></strong>：Apple ID账号名。</p>
<p>（4）<strong><em>TeamIdentifier</em></strong>：Team Identity。</p>
<p>（5）<strong><em>AppIDName</em></strong>：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。</p>
<p>（6）<strong><em>ApplicationIdentifierPrefix</em></strong>：完整App ID的前缀（TeamIdentifier.*）。</p>
<p>（7）<strong><em>DeveloperCertificates</em></strong>：包含了可以为使用该配置文件应用签名的所有证书<data><array>。</array></data></p>
<p>证书是基于Base64编码，符合PEM(PrivacyEnhanced Mail, RFC 1848)格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。</p>
<p>从DeveloperCertificates提取<data></data>之间的内容到文件cert.cer（cert.perm）：</p>
<p>—–BEGIN CERTIFICATE—–</p>
<p>将<data></data>之间的内容拷贝至此</p>
<p>—–END CERTIFICATE—–`</p>
<p>Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥KeyPair配对）应吻合；Windows下没有足够信息（WWDRCA.cer），无法验证该证书。</p>
<p>如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。</p>
<p>（8）<strong><em>Entitlements</em></strong>键<key>对应的<dict>：</dict></key></p>
<p><strong>keychain-access-groups</strong>：$(AppIdentifierPrefix)，参见<strong><em>Code Signing Entitlements</em></strong>(*.entitlements)。</p>
<p>每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的<strong>keychain</strong>，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。</p>
<p><strong>application-identifier</strong>：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。</p>
<p><strong>com.apple.security.application-groups</strong>：App Group ID（group. com.apple），参见<strong><em>Code Signing Entitlements</em></strong>(*.entitlements)。</p>
<p><strong>com.apple.developer.team-identifier</strong>：同Team Identifier。</p>
<p>（9）<strong><em>Provisioned Devices</em></strong>：该mobileprovision授权的开发设备的UDID <array>。</array></p>
<p>Provisioning Profile<strong>被配置到</strong>【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。</p>
<p>####五.开发组供应配置文件<br>（<strong>Team Provisioning Profiles</strong>）<strong>每个Apple开发者账号都对应一个唯一的</strong>Team ID，<strong>Xcode3.2.3预发布版本中加入了Team Provisioning Profile这项新功能。<br>在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑</strong>自动生成*<em>iOS Team Provisioning Profile（Managed by Xcode）。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-478b680d2dd8b28a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(</em>)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个eam注册的所有设备上调试所有的应用程序（不管bundleidentifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOSTeam Provisioning Profile。<br>Team Provisioning Profile生成/更新时机：<br>Add an Apple ID account to Xcode<br>Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode<br>Assign Your App to a Team in Xcode project settings of General|Identity<br>Register new device on the apple development website or Xcode detected new device connected</p>
<p>利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。<br>Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也<strong>被配置到</strong>【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。</p>
<p>####六.App Group （ID）<br><strong>WWDC14除了发布了OS X v10.10和switf外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。<br>扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group <a href="http://lib.csdn.net/base/docker" target="_blank" rel="noopener">Container</a>。<br>用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。<br>Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范：<br>假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.*</strong>extImportRecording***”。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-59399d05ca6d0f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。<br>App Group会<strong>被配置到</strong>【Xcode Target|Build Settings|Code Signing|Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。</p>
<p>###七.证书与签名（Certificate&amp; Signature）<br><img src="http://upload-images.jianshu.io/upload_images/2647951-4a248d32b62eff79?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>每个证书（其实是公钥）对应的<strong>私钥</strong>会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字<strong>签名</strong>（CodeSign）——使用哈希<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>生成内容<strong>摘要</strong>（digest）。上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。<br>iOS/Mac机上的ios_development.cer可以被AppleWWDRCA.cer中的 public key解密，从而获取每个开发证书中可信任的公钥。<br><strong>1.iOS/Mac设备（系统）使用CA证书</strong>（WWDRCA.cer）<strong>来判断App Provisioning Profile（Code Signing Identity）的合法性：</strong><br>若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信；<br>再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。</p>
<p><strong>2.iOS/Mac设备（系统）使用AppProvisioning Profile</strong>（Code Signing Identity）<strong>证书来判断App的合法性：</strong><br>若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信；<br>再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。</p>
<p>###八.在多台机器上实现开发账户/证书共享<br><strong>若在Xcode Preferences添加了该Accounts，选中Team条目|ViewDetails：可以查看Signing Identities和Provisioning Profiles。<br>选中欲导出的Account，点击+-之后的☸|ExportAccounts，可导出包含account/code signingidentity/provisioning profiles信息的*.</strong>developerprofile<strong>（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。<br>选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权exportkey “privateKey” from keychain，将导出</strong>Certificates.p12；<strong>或在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出</strong>Certificates.p12**。</p>
<p>其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件即可在iOS真机设备上开发调试。</p>
<p>###九.证书配置常见错误</p>
<ol>
<li>Xcode Target|Genera|Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.”<br>Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioningprofile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！<br>2.Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioningprofile之后，Code Signing Identity中下拉提示No identities from profile “…”or No identities from keychain.<br>Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（No identities are available）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（<em>.developerprofile）或共享证书(</em>.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。<br>3.”Invalid application-identifier Entitlement”or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).”<br><strong>（1）</strong>检查对应版本（Debug）指定的*.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。<br><strong>（2）也可以将</strong>Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。<br>4.Xcode配置反应有时候不那么及时，可刷新、重置相关配置项开关（若有）或重启Xcode试试。</li>
</ol>
<p><strong>参考：</strong></p>
<p>《iPhone真机调试应用程序》《iOS Developer：真机测试》<br>《iOS Development–Certificates, Provisioning Profiles》<br>《关于Certificate、Provisioning Profile、App ID的介绍及其关系》</p>
<p>《iOS keyChain 研究》<br>《数字签名和数字证书》<br>《苹果开发者账号那些事儿》<br>《iOS Code Signing 学习笔记》<br>《代码签名探析/Inside Code Signing》<br>《iOS Code Signing: 解惑/iOS Code Signing: Under The Hood》<br>转载：<a href="http://blog.csdn.net/lw_chen/article/details/48709901" target="_blank" rel="noopener">iOS开发证书要点详解，ios证书详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS开发证书要点详解，ios证书详解/" data-id="cjgdiqq77000ikezicoovjhrg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-WKWebView与JS交互" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-WKWebView与JS交互/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-WKWebView与JS交互/">iOS-WKWebView与JS交互</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.1 WKScriptMessageHandler协议</p>
<p>WKScriptMessageHandler其实就是一个遵循的协议，它能让网页通过JS把消息发送给OC。其中协议方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*! @abstract Invoked when a script message is received from a webpage.</span><br><span class="line"> @param userContentController The user content controller invoking the</span><br><span class="line"> delegate method.</span><br><span class="line"> @param message The script message received.</span><br><span class="line"> */</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br></pre></td></tr></table></figure></p>
<p>从协议中我们可以看出这里使用了两个类WKUserContentController和WKScriptMessage。WKUserContentController可以理解为调度器，WKScriptMessage则是携带的数据。</p>
<p>1.2 WKUserContentController</p>
<p>WKUserContentController有两个核心方法，也是它的核心功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)addUserScript:(WKUserScript *)userScript;: js注入，即向网页中注入我们的js方法，这是一个非常强大的功能，开发中要慎用。</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;：添加供js调用oc的桥梁。这里的name对应WKScriptMessage中的name，多数情况下我们认为它就是方法名。</span><br></pre></td></tr></table></figure></p>
<p>1.3 WKScriptMessage</p>
<p>WKScriptMessage就是js通知oc的数据。其中有两个核心属性用的很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly, copy) NSString *name; ：对应- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;添加的name。</span><br><span class="line">@property (nonatomic, readonly, copy) id body;：携带的核心数据。</span><br></pre></td></tr></table></figure></p>
<p>js调用时只需<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</span><br></pre></td></tr></table></figure></p>
<p>这里的name就是我们添加的name。</p>
<p>###一、JS调OC代码</p>
<p>JS代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">&lt;body style=&quot;background-color: white;&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function jsCallNative() &#123;</span><br><span class="line">           window.webkit.messageHandlers.callNativeAndSend.postMessage(&apos;callcallcall&apos;);</span><br><span class="line">           alert(callNative);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;jsCallNative()&quot; style=&quot;width:100%; height:30px;&quot;/&gt;调用OC代码&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意：window.webkit.messageHandlers.callNativeAndSend.postMessage(‘callcallcall’);这行代码才是调用oc的方法，方法名：callNativeAndSend 参数就是：callcallcall</p>
<p>OC代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WKUserContentController *userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">       [userContentController addScriptMessageHandler:self name:@&quot;callNativeAndSend&quot;];</span><br><span class="line">       [userContentController addScriptMessageHandler:self name:@&quot;NativeObject.shareString&quot;];</span><br><span class="line">       // WKWebView的配置</span><br><span class="line">       WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">       configuration.userContentController   = userContentController;</span><br><span class="line">       //创建WKWebView</span><br><span class="line">       </span><br><span class="line">       _webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenHeight) configuration:configuration];</span><br></pre></td></tr></table></figure></p>
<p>上面代码，是创建webView，并且告诉JS有哪些方法。</p>
<p>Adding a script message handler with name name causes the JavaScript function window.webkit.messageHandlers.name.postMessage(messageBody) to be defined in all frames in all web views that use the user content controller.<br>译：添加名称名称的脚本消息处理程序会导致在所有使用用户内容控制器的Web视图的所有框架中定义JavaScript函数window.webkit.messageHandlers.name.postMessage（messageBody）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addScriptMessageHandler:(id&lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br></pre></td></tr></table></figure></p>
<p>但是 [userContentController addScriptMessageHandler:self name:@”NativeObject.shareString”];亲测是无效的，其只能像[userContentController addScriptMessageHandler:self name:@”callNativeAndSend”];添加这种。</p>
<p>当JS调用OC方法后，会执行以下回调，name是方法名，可以用其作区分判断，body是参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">    NSLog(@&quot;\n body:%@ \n name:%@&quot;,message.body,message.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外还有一种注入JS的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addUserScript:(WKUserScript *)userScript;: js注入，即向网页中注入我们的js方法，这是一个非常强大的功能，开发中要慎用。</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：在UIWebview中，当我们第一次给h5注入js方法后，在后续的页面操作过程中可能会丢失这个方法，也就是js不再能拿到这个方法。可能原因是：在h5页面操作过程中，创建了两个window，而我们加的js方法仍在第一个window上，在新的window上就拿不到了。在WKWebview中，丢失方法是因为js调用方法调早了，而我们还没有注入；js延迟调用问题不存在了。</strong> <strong>在WKWebview中用上述方式注入代码后会避免此问题出现*！！！</strong></p>
<p>###二、OC调JS代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[webView evaluateJavaScript:@&quot;globalObject.nativeCallJS(&apos;abc&apos;)&quot; completionHandler:^(id _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;error:%@&quot;,error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>abc是传递给JS的参数，globalObject是JS中全局属性，nativeCallJS是其下的方法。</p>
<p>###三、优化<br>[userContentController addScriptMessageHandler:self name:@”callNativeAndSend”]<br>当我们添加注入方法时，以上代码会强引用self，即当前控制器，会导致再dealloc的时候self不会释放，解决办法是创建一个新类，并实现WKScriptMessageHandler代理方法。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WeakScriptMessageDelegate.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;WebKit/WebKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface WeakScriptMessageDelegate : NSObject&lt;WKScriptMessageHandler&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id&lt;WKScriptMessageHandler&gt; scriptDelegate;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDelegate:(id&lt;WKScriptMessageHandler&gt;)scriptDelegate;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WeakScriptMessageDelegate.m</span><br><span class="line"></span><br><span class="line">#import &quot;WeakScriptMessageDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation WeakScriptMessageDelegate</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDelegate:(id&lt;WKScriptMessageHandler&gt;)scriptDelegate</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _scriptDelegate = scriptDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message</span><br><span class="line">&#123;</span><br><span class="line">    [self.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>尽管如此，在self里还是要在dealloc的时候移除方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[_wkWebView configuration].userContentController removeScriptMessageHandlerForName:@&quot;jsCallNative&quot;];</span><br></pre></td></tr></table></figure></p>
<p>执行上述代码之后，self和WeakScriptMessageDelegate都能安全释放。</p>
<p>推荐一个强大的苹果官方库，JavaScriptCore 以及 <a href="http://www.jianshu.com/p/459cb886e863" target="_blank" rel="noopener">iOS JavaScriptCore使用</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-WKWebView与JS交互/" data-id="cjgdiqq6v0005kezihsk55pex" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-App-Store-审核指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/App-Store-审核指南/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/App-Store-审核指南/">App-Store-审核指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简介<br>App 正在改变世界，丰富人们的生活，并为像您一样的开发者提供前所未有的创新机会。因此，App Store 已成长为一个激动人心且充满活力的生态系统，正为数百万的开发者和超过十亿的用户提供服务。不管是开发新手，还是由经验丰富的程序员所组成的大型团队，我们都非常欢迎您为 App Store 开发 app，并希望能够帮助您了解我们的准则，以确保您的 app 能够快速通过审核流程。<br>App Store 的指导原则非常简单 - 我们希望为用户获取 app 时提供更安全可靠的体验，并为所有开发者提供借助 app 获得成功的契机。我们已按照这一原则更新了 App Review 指南。新版指南本身核心内容并没有任何变化，但其规划得更有条理，且包含更多背景以便理解。在后续页面中，您会发现这些准则已被清晰地划分为五个部分：安全、性能、业务、设计及法律。另外，请将以下几点谨记在心：<br>我们发现很多儿童都会大量下载各种 app。尽管家长控制功能能为儿童提供有效保护，但您也必须做好自己份内的工作。因此，您要知道，我们时刻都在关注这些儿童。<br>如果您的 App 看起来像是在几天内仓促拼凑而成的，或者您为了获得朋友的称赞而试图在该商店内发布自己的第一款练习 App，那么请做好被拒绝的准备。我们有许多严肃认真的开发者，他们不希望自己的精品被淹没在业余开发者开发的 App 中。<br>如果我们认为 App 的任何内容或行为超出了可接受的范围，我们将拒绝该 App。您可能会问，这个可接受的范围是什么？套用最高法院大法官的一句话：“当我看到的时候，我就知道了”。而且，我们相信，当您超出这个范围时，您自己也会意识到。<br>如果您试图欺骗系统（例如，试图在审核流程中弄虚作假，窃取用户数据，抄袭其他开发者的作品，或者操纵评级），我们会从该商店中移除您的 App，并将您从 Developer Program 中除名。</p>
<p>我们希望这些新准则能帮助您顺利通过 App Review 流程，并使批准和拒绝标准在整体上更加一致。本文是一个动态文稿；如果新的 App 引发了新的问题，我们可能会随时制定新的规则。也许，您的 App 就将促成新的规则。我们同样热爱 App 开发，并且尊重您所做的一切。我们正竭尽全力为您营造世界上最优秀的平台，既能让您展示才华，还能让您获得回报。</p>
<p>目录<br><a href="https://developer.apple.com/app-store/review/guidelines/cn/#before-you-submit" target="_blank" rel="noopener">提交之前</a> – 审核前核对清单</p>
<ol>
<li><p><a href="https://developer.apple.com/app-store/review/guidelines/cn/#safety" target="_blank" rel="noopener">安全</a><br>1.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#objectionable-content" target="_blank" rel="noopener">令人反感的内容</a><br>1.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#user-generated-content" target="_blank" rel="noopener">用户生成的内容</a><br>1.3 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#kids-category" target="_blank" rel="noopener">儿童类别</a><br>1.4 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#physical-harm" target="_blank" rel="noopener">人身伤害</a><br>1.5 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#developer-information" target="_blank" rel="noopener">开发者信息</a></p>
</li>
<li><p><a href="https://developer.apple.com/app-store/review/guidelines/cn/#performance" target="_blank" rel="noopener">性能</a><br>2.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#app-completeness" target="_blank" rel="noopener">App 完成度</a><br>2.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#beta-testing" target="_blank" rel="noopener">测试版 App</a><br>2.3 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#accurate-metadata" target="_blank" rel="noopener">准确的元数据</a><br>2.4 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#hardware-compatibility" target="_blank" rel="noopener">硬件兼容性</a><br>2.5 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#software-requirements" target="_blank" rel="noopener">软件要求</a></p>
</li>
<li><p><a href="https://developer.apple.com/app-store/review/guidelines/cn/#business" target="_blank" rel="noopener">业务</a><br>3.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#payments" target="_blank" rel="noopener">付款</a>3.1.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#in-app-purchase" target="_blank" rel="noopener">App 内购买</a><br>3.1.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#subscriptions" target="_blank" rel="noopener">订阅</a><br>3.1.3 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#content-based-reader-apps" target="_blank" rel="noopener">基于内容的“阅读器”App</a><br>3.1.4 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#content-codes" target="_blank" rel="noopener">内容代码</a><br>3.1.5 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#physical-goods-and-services" target="_blank" rel="noopener">App 之外的实物商品和服务</a><br>3.1.6 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#apple-pay" target="_blank" rel="noopener">Apple Pay</a></p>
</li>
</ol>
<p>3.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#other-business-model-issues" target="_blank" rel="noopener">其他业务模式问题</a>3.2.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#acceptable" target="_blank" rel="noopener">可以接受</a><br>3.2.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#unacceptable" target="_blank" rel="noopener">不可接受</a></p>
<ol start="4">
<li><p><a href="https://developer.apple.com/app-store/review/guidelines/cn/#design" target="_blank" rel="noopener">设计</a><br>4.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#copycats" target="_blank" rel="noopener">抄袭者</a><br>4.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#minimum-functionality" target="_blank" rel="noopener">最低功能要求</a><br>4.3 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#spam" target="_blank" rel="noopener">垃圾 App</a><br>4.4 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#extensions" target="_blank" rel="noopener">扩展功能</a><br>4.5 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#apple-sites-and-services" target="_blank" rel="noopener">Apple 站点和服务</a></p>
</li>
<li><p><a href="https://developer.apple.com/app-store/review/guidelines/cn/#legal" target="_blank" rel="noopener">法律</a><br>5.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#privacy" target="_blank" rel="noopener">隐私</a>5.1.1 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#data-collection-and-storage" target="_blank" rel="noopener">数据收集和存储</a><br>5.1.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#data-use-and-sharing" target="_blank" rel="noopener">数据使用和共享</a><br>5.1.3 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#health-and-health-research" target="_blank" rel="noopener">健康和健康研究</a><br>5.1.4 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#kids" target="_blank" rel="noopener">儿童</a><br>5.1.5 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#location" target="_blank" rel="noopener">定位服务</a></p>
</li>
</ol>
<p>5.2 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#intellectual-property" target="_blank" rel="noopener">知识产权￼</a><br>5.3 <a href="https://developer.apple.com/app-store/review/guidelines/cn/#gaming-gambling-and-lotteries" target="_blank" rel="noopener">游戏、赌博和彩票</a></p>
<p><a href="https://developer.apple.com/app-store/review/guidelines/cn/#after-you-submit" target="_blank" rel="noopener">提交之后</a> – 预期事宜</p>
<p>提交之前<br>为了帮助您尽可能顺利地通过 App 审批，请查看下方列出的常见错误行为，这些行为可能会导致审核流程延误或导致 App 被拒。这些内容不能代替准则或保证 App 获批，但确保核对该列表中的每一项会是一个良好的开始。<br>请确保：<br>测试 App 是否会发生崩溃、是否存在错误<br>确保所有 App 信息及元数据完整且正确<br>更新您的联系信息，以便 App Review 部门在需要时与您取得联系<br>提供有效的演示帐户和登录信息，以及审核 App 时所需的任何其他硬件或资源（例如，示例二维码）<br>启用后台服务，以使其在审核期间处于活动和可用状态<br>在 App Review 备注中附上与非明显特性及 IAP 相关的详细说明，包括支持文稿（如适用）。如果由于地区锁定或其他限制而导致我们无法访问 App 的部分内容，请提供有关功能的视频链接<br>检查 App 是否遵循了其他文稿中的相关指南，如：</p>
<p>开发指南<br><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="noopener">App Programming Guide</a><br><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/" target="_blank" rel="noopener">App Extension Programming Guide</a><br><a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="noopener">iOS Data Storage Guidelines</a><br><a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672" target="_blank" rel="noopener">macOS File System Documentation</a><br><a href="https://developer.apple.com/library/content/documentation/Tools/Conceptual/SafariExtensionGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Safari Extensions Development Guide</a><br><a href="https://developer.apple.com/go/?id=itunes-connect-developer-guide" target="_blank" rel="noopener">iTunes Connect Developer Guide</a></p>
<p>设计指南<br><a href="https://developer.apple.com/ios/human-interface-guidelines/" target="_blank" rel="noopener">iOS Human Interface Guidelines</a><br><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/OSXHIGuidelines/" target="_blank" rel="noopener">macOS Human Interface Guidelines</a><br><a href="https://developer.apple.com/tvos/human-interface-guidelines/" target="_blank" rel="noopener">tvOS Human Interface Guidelines</a><br><a href="https://developer.apple.com/watchos/human-interface-guidelines/" target="_blank" rel="noopener">watchOS Human Interface Guidelines</a></p>
<p>品牌和营销准则<br><a href="https://developer.apple.com/app-store/marketing/guidelines/cn/" target="_blank" rel="noopener">App Store 营销准则</a><br><a href="https://developer.apple.com/apple-pay/Apple-Pay-Identity-Guidelines-CN.pdf" target="_blank" rel="noopener">Apple Pay 识别标志指南</a><br><a href="https://developer.apple.com/wallet/Add-to-Apple-Wallet-Guidelines.pdf" target="_blank" rel="noopener">Add to Apple Wallet Guidelines</a><br><a href="http://www.apple.com/legal/intellectual-property/guidelinesfor3rdparties.html" target="_blank" rel="noopener">Guidelines for Using Apple Trademarks and Copyrights</a></p>
<ol>
<li>安全<br>当用户通过 App Store 安装 App 时，他们希望获得安全的体验：App 不含令人不快或具有攻击性的内容，不会损坏他们的设备，不会在使用中造成人身伤害。我们在下方列出了主要的安全隐患。如果您想恐吓、攻击他人，则您的 App 不适合出现在 App Store 中。<br><strong>1.1 令人反感的内容</strong>App 不应包含具有攻击性、不顾及他人感受、令人不安、惹人厌恶或低俗不堪的内容。此类内容的示例有：<br><strong>1.1.1</strong> 诽谤或恶意内容，包括有关宗教、种族、性取向、性别或其他目标群体的引用或评论，特别是当 App 很可能对特定的个人或团体造成伤害时。专业政治讽刺和政治幽默作家通常无需遵循这一要求。<br><strong>1.1.2</strong> 人类或动物遭到杀害、残害、酷刑、虐待的写实描绘，或者鼓励暴力的内容。在游戏中，“敌人”不能单单针对特定种族、文化、真实存在的政府或企业，或是任何其他真实存在的实体。<br><strong>1.1.3</strong> 鼓励非法使用或不负责任地使用武器和危险物品的描述，或者促进军火购买的描述。<br><strong>1.1.4</strong> 过于色情的内容（韦氏词典对“色情”一词的定义是：对性器官或性活动的露骨描述或展示，目的在于刺激性快感，而非带来美学价值或触发情感）。<br><strong>1.1.5</strong> 具有煽动性的宗教评论，或者对宗教文本进行错误或误导性的引用。<br><strong>1.1.6</strong> 虚假信息和功能，其中包括不准确的设备数据或用于恶作剧/开玩笑的功能，如虚假的位置跟踪器。即使指明 App“仅供娱乐”，也不能违背这一准则。支持匿名或恶作剧电话或短信/彩信的 App 会被拒绝。</li>
</ol>
<p><strong>1.2 用户生成的内容</strong>对于包含用户生成内容的 App，有特定的难题需要解决，比如知识产权侵权、匿名欺凌等。为了避免滥用，包含用户生成内容或社交网络服务的 App 必须满足以下条件：<br>采用相应的方法来过滤令人反感的内容，以免这些内容在 App 中发布<br>制定一个机制，以举报攻击性内容并在出现问题时及时作出回应<br>若用户发布攻击性内容，可以取消其使用服务的资格<br>公布联系信息，以便用户与您联系</p>
<p>如果 App 中所含的用户生成内容或服务最终主要用于色情内容、客观化现实生活中的某人（如“性感与否”投票）、进行人身威胁或欺凌，则这些 App 不适合出现在 App Store 中，它们可能会在未经通知的情况下被移除。如果 App 中所含的用户生成内容来自于基于 Web 的服务，则可显示意外产生的“ NSFW（公众场所不宜）”内容，前提是这些内容是默认隐藏的，只有当用户通过您的网站将其打开时才会显示。</p>
<p><strong>1.3 儿童类别</strong>“儿童类别”可帮助用户轻松地找到适合儿童的 App。如果您希望参与“儿童类别”，则应该致力于为年纪较小的用户量身打造卓越的使用体验。这些 App 不得提供 App 外链接、购买机会或其他会对儿童造成干扰的内容，除非其保留在受家长监控的指定区域中。请谨记，只要客户希望您的 App 能够满足“儿童类别”的要求，您的 App 就需要一直满足后续更新中的相应准则；即使您决定取消选择此类别，也是如此。进一步了解<a href="https://developer.apple.com/app-store/parental-gates/" target="_blank" rel="noopener">家长监控</a>。<br>“儿童类别”中的 App 不得展示行为广告（例如，广告主不得根据用户在 App 中的活动投放广告），而且所有内容相关广告都必须适合儿童观看。您还应特别留意世界各地与在线收集儿童数据相关的隐私法。请务必查阅这些准则的<a href="https://developer.apple.com/app-store/review/guidelines/cn/#privacy" target="_blank" rel="noopener">“隐私”部分</a>，以了解更多信息。</p>
<p><strong>1.4 人身伤害</strong>如果 App 的行为方式可能会造成人身伤害，我们可能会拒绝该 App。例如：<br><strong>1.4.1</strong> 如果医疗 App 可能会提供错误的数据或信息，或用于诊断或治疗病患，则这些 App 可能会面临更加严格的审核。如果您的医疗 App 已经获得监管部门的批准，请随 App 提交相关文稿的链接。<br><strong>1.4.2</strong> 药物剂量计算器必须来自药品生产企业、医院、大学、健康保险公司，或是经过 FDA 或其相应国际部门的批准的其他实体。由于可能会对病患造成伤害，我们需要确保 App 将在长时间内获得支持，并保持更新。<br><strong>1.4.3</strong> App 不得鼓励非法使用毒品或过量摄入酒精；或者鼓励未成年人购买毒品、酒精或烟草；不允许为大麻销售提供便利。<br><strong>1.4.4</strong> App 只能显示由相关执法部门公布的酒后驾车检查点，不得鼓励酒后驾车和包括超速在内的其他鲁莽行为。<br><strong>1.4.5</strong> App 不得促使客户以违背 Apple 硬件安全文稿的方式，或以可能会造成设备或人身伤害的方式来使用他们的设备。例如，App 不得鼓励用户在充电时将设备放置在床垫和枕头之下。请查阅<a href="https://support.apple.com/" target="_blank" rel="noopener">设备文稿</a>。</p>
<p><strong>1.5 开发者信息</strong>用户需要知道如何就疑问和支持问题与您取得联系。请确保您的支持 URL 中包含便捷的联系方式。如果未能提供准确的最新联系信息，不但会让客户有不好的感受，可能还会违反某些国家/地区的法律。另外，请确保在 Wallet 凭证中包含发卡机构的有效联系方式，以及分配给凭证的品牌或商标所有者的专用证书。</p>
<ol start="2">
<li>性能<br><strong>2.1 App 完成度</strong>提交以供审核的 App 应该是最终版本，应包含所有必要的元数据和全功能的 URL；占位符文本、空白网站以及其他临时内容应在提交前清除。在提交 App 之前，请务必在设备上对 App 错误和稳定性进行测试；如果您的 App 需要登录，请提供演示帐户信息（并打开您的后台服务！）。如果您在 App 中提供了 App 内购买，请确保审核人员能够看到这些内容，并确保这些内容处于完整且最新的状态，否则请在审核备注中说明相关原因。请不要将 App Review 视作软件测试服务。我们将拒绝不完整的 App 套装以及会出现崩溃或存在明显技术问题的二进制文件。</li>
</ol>
<p><strong>2.2 测试版 App</strong>App 的演示版、测试版和试用版不适合出现在 App Store 中 - 请使用 TestFlight。所有通过 TestFlight 提交以进行测试发布的 App 都应旨在公开发布，并应遵循“App Review 准则”。请注意，使用 TestFlight 的 App 不得分发给测试者用以换取任何类型的报酬，包括作为众筹资金的奖励。对于测试版 App 的大幅更新应先提交至 TestFlight App Review 团队，然后再分发给您的测试者。要了解更多信息，请访问“<a href="https://developer.apple.com/testflight/" target="_blank" rel="noopener">TestFlight Beta Testing</a>”。</p>
<p><strong>2.3 准确的元数据</strong>客户应该知道他们在下载或购买您的 App 时会得到什么，所以请确保 App 的描述、屏幕快照和预览能够准确反映 App 的核心体验，并记得不断更新，以便保持与新版本相应的最新状态。<br><strong>2.3.1</strong> 请勿在 App 中包含未记录的功能或隐藏功能；不管是对于最终用户还是 App Review 团队，App 功能都应清晰可见。如果出现恶劣或屡教不改的行为，则可能会从 Apple Developer Program 中除名。我们正努力将 App Store 打造成值得信赖的生态系统，并希望我们的 App 开发者也能如此；如果您不诚实以待，我们之间就不会有任何业务往来。<br><strong>2.3.2</strong> 如果您的 App 包含 App 内购买，请确保 App 的描述、屏幕快照和预览清楚地指明是否有需要另行购买的精选项目、关卡、订阅等。<br><strong>2.3.3</strong> 屏幕快照应展示 App 的使用情况，而非仅显示标题封面、登录页面或初始屏幕。<br><strong>2.3.4</strong> 预览是让客户了解 App 外观和功能的好方法。为了确保客户理解他们将在 App 中获得的体验，预览或许只会使用从 App 中捕获的视频屏幕。表情贴纸和 iMessage 扩展可以将用户体验展示在“信息”App 中。您也可以添加旁白和视频，或添加文本说明，以帮助说明任何无法仅通过视频进行阐明的内容。<br><strong>2.3.5</strong> 请为 App 选择最适合的类别，并在需要帮助时参考“<a href="https://developer.apple.com/app-store/categories/" target="_blank" rel="noopener">App Store 类别定义</a>”。如果选择的类别与实际情况相差较远，我们可能会更改 App 的类别。<br><strong>2.3.6</strong> 请在 iTunes Connect 中诚实地回答年龄段分级问题，以使 App 与家长控制功能的分级保持一致。如果 App 分级有误，客户在获得 App 时可能会感到诧异，或促使政府监管部门展开相应调查。<br><strong>2.3.7</strong> 请选择一个独一无二的 App 名称，指定能够准确描述 App 的关键词，不要试图用商标术语、流行 App 的名称或其他不相关的短语来包装任何元数据，以此欺骗系统。App 名称必须限制在 50 个字符以内，且不得包含不属于 app 名称的词语或描述。Apple 可能会随时修改不合适的关键词。<br><strong>2.3.8</strong> 元数据应适合所有受众，所以请确保您的图标、屏幕快照和预览保持在 4+ 年龄分级；即使您的 App 分级更高，也应如此。例如，如果您的 App 是包含暴力的游戏，请勿选择包含惨烈的死亡或用枪瞄准特定角色的图像。请务必确保包括 App 名称和图标（小图标、大图标、Apple Watch App 等）在内的元数据彼此相似，以免引起困惑。<br><strong>2.3.9</strong> 您应负责确保有权使用 App 图标、屏幕快照和预览中的所有材料，并应显示虚构的帐户信息，而非真实个人的数据。<br><strong>2.3.10</strong> 请确保您的 App 注重 iOS、Mac、Apple TV 或 Apple Watch 体验，并且不在 App 或元数据中包含其他移动平台的名称、图标或图像，除非存在已获批的特定互动功能。</p>
<p><strong>2.4 硬件兼容性**</strong>2.4.1<strong> 为了确保用户能够充分利用您的 App，iPhone App 应尽量能在 iPad 上运行。我们鼓励您考虑开发通用 App，这样客户就可以在所有设备上加以使用。进一步了解<a href="https://developer.apple.com/go/?id=xcode-universal" target="_blank" rel="noopener">通用 App</a>。
</strong>2.4.2<strong> 通过设计，使 App 节省能耗。App 不应快速耗尽电池电能、产生过多的热量或对设备资源造成不必要的负担。
</strong>2.4.3<strong> 对于 Apple TV app，应确保用户无需使用除 Siri Remote 或第三方游戏控制器之外的硬件输入，但您可以随意提供增强功能供连接其他外围设备时使用。如果需要用户配备游戏控制器，请务必在元数据中加以明确说明，以便用户知晓他们需要额外的设备才能玩游戏。
</strong>2.4.4<strong> App 不得建议或要求重新启动设备。
</strong>2.4.5<strong> 对于通过 Mac App Store 分发的 App，还有几个额外要求需要您牢记在心：</strong>(i)<strong> 这些 App 必须适当地沙盒化，并遵循“<a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672" target="_blank" rel="noopener">macOS File System Documentation</a>”。另外，这些 App 只应使用相应的 macOS API 来修改其他 App 存储的用户数据（如书签、“地址簿”或“日历”条目）。
</strong>(ii)<strong> 这些 App 必须使用 Xcode 中提供的技术来进行打包和提交；不允许使用第三方安装器。另外，这些 App 必须是单个的自包含应用程序安装包，不能将代码或资源安装在共享位置。
</strong>(iii)<strong> 这些 App 不得自动启动或者在启动时包含其他自动运行的代码，不得在未经同意的情况下登录，也不得大量生成在用户退出 app 后仍在未经同意的情况下继续运行的进程。这些 App 不得将图标自动添加到 Dock 中，或在用户桌面上留下快捷方式。
</strong>(iv)<strong> 这些 App 不得下载或安装独立的 App、kext、额外代码或资源，以向我们在审核过程中看到的 App 添加功能，或进行大幅更改。
</strong>(v)<strong> 这些 App 不得申请升级至 root 特权或使用 setuid 属性。
</strong>(vi)<strong> 这些 App 不得在启动时显示许可证屏幕、需要使用许可证密匙或实施自己的拷贝保护措施。
</strong>(vii)<strong> 这些 App 必须使用 Mac App Store 分发更新；不允许使用其他更新机制。
</strong>(viii)<strong> 这些 App 应在目前随附的 OS 上运行，不得使用已停用或选装的技术（如 Java、Rosetta）
</strong>(ix)** 这些 App 必须在单个 App 套装内包含所有的语言和本地化支持。</p>
<p><strong>2.5 软件要求**</strong>2.5.1<strong> App 可以只使用公共 API。进一步了解<a href="https://developer.apple.com/reference/" target="_blank" rel="noopener">公共 API</a>。
</strong>2.5.2<strong> App 应自包含在其套装中，不得在指定容器范围外读取或写入数据，不得下载、安装或执行代码，包括其他 iOS、watchOS、macOS 或 tvOS App。
</strong>2.5.3<strong> 如果 App 传输的病毒、文件、计算机代码或程序会对操作系统和/或硬件功能（包括推送通知和 Game Center）的正常运行造成负面影响或导致其中断，则该 App 会被拒绝。如果出现恶劣的违规行为或屡教不改的行为，则会导致从 Apple Developer Program 中除名。
</strong>2.5.4<strong> 多任务处理 App 只允许在实现预期用途时使用后台服务：VoIP、音频播放、地理位置、任务完成记录和本地通知等。如果 App 使用定位后台模式，请提醒用户，这么做会大幅缩短电池使用时间。
</strong>2.5.5<strong> 我们将在 IPv6 网络上进行审核。如果您的 App 无法与 IPv6 寻址功能兼容，则可能无法通过审核。
</strong>2.5.6<strong> 如果 App 会浏览网页，则必须使用相应的 WebKit 框架和 WebKit Javascript。
</strong>2.5.7<strong> 基于蜂窝移动网络且超过 10 分钟的视频流内容必须使用 HTTP Live Streaming，并包含一个基准 192 kbps HTTP Live Stream。
</strong>2.5.8<strong> 如果 App 会创建替代的桌面/主屏幕环境，或者模拟多应用 Widget 体验，则该 App 会遭到拒绝。
</strong>2.5.9<strong> 如果 App 会改变标准开关（如音量增/减和铃声/静音开关）的功能，或改变其他的原生用户界面元素或行为，则该 App 会遭到拒绝。
</strong>2.5.10<strong> 不得提交包含空白广告横幅或测试广告的 App。
</strong>2.5.11<strong> SiriKit</strong>(i)<strong> 集成 SiriKit 的 app 只能登记无需其他 app 支持便可处理的意图，而且该意图应当与用户对所述功能的预期相符。例如，如果您的 app 属于膳食计划 app，则不应融入开始体能训练的意图，即使该 app 共享了与健身 app 的集成也不可以。
</strong>(ii)<strong> 确保 plist 中的词汇和短语与您的 app 及其所登记意图的 SiriKit 功能相符。
</strong>(iii)** 以最直接的方式解析 Siri 请求，不要在请求与实现之间插入任何广告或其他市场营销信息。只有在完成相关任务需要时（例如让用户指定特定类型的体能训练时），才可以显示插页式用户界面。</p>
<ol start="3">
<li>业务<br>在 App Store 中，您可以通过多种方式让自己的 App 实现盈利。如果您的业务模式并不显而易见，请务必在其元数据和 App Review 备注中加以说明。如果我们无法理解 App 的工作方式，或者 App 内购买不是那么一目了然，则审核会有所延误，并可能会导致 App 被拒绝。尽管价格由您决定，但是我们不会分发要价明显过高的 App 和 App 内购买项目。对于试图以不合常理的高昂价格欺骗用户的 App，我们将予以拒绝。<br>如果我们发现您试图操纵评价，通过付费、提供奖励、经过筛选或伪造的反馈来提高排名，或者要求第三方服务代您这样做，我们将采取相应措施以保持 App Store 的完整性，其中可能包括将您从 Apple Developer Program 中除名。<br><strong>3.1 付款**</strong>3.1.1 App 内购买：**如果您想要在 app 内解锁特性或功能（解锁方式有：订阅、游戏内货币、游戏关卡、优质内容的访问权限或解锁完整版等），则必须使用 App 内购买。App 不得包含指引客户使用非 IAP 机制进行购买的按钮、外部链接或其他行动号召用语。<br>通过 IAP 购买的所有点数和游戏货币必须在 app 内使用且不得过期，并且您应确保为所有可恢复的“App 内购买”设计一套恢复机制。<br>请务必指定正确的可购买类型，否则您的 app 将被拒绝。<br>App 不得直接或间接地将 IAP 内容、功能或消耗品赠予他人。<br>通过 Mac App Store 分发的 app 可托管基于非 App Store 机制的插件或扩展功能。</li>
</ol>
<p><strong>3.1.2 订阅：</strong>无论属于 App Store 上哪一类别，App 都可以提供自动续订的 App 内购买订阅。在 app 内集成可自动续订的订阅时，请务必遵循下述指导原则。<br><strong>3.1.2(a) 允许的用途：</strong>如果您提供自动续订订阅，则必须为客户提供持续的价值。以下并非详尽列表，适当的订阅示例包括：新游戏关卡；连载内容；多玩家支持；持续提供实质性更新的 app；对媒体内容的大型合集或持续更新的访问权限；软件即服务 (SAAS)；以及云服务支持。此外：订阅可与单点式服务一起提供。例如，您可以提供整个影片库的订阅，以及单部影片购买或租赁。<br>您可以提供在您自己的不同 app 间共享的单一订阅，但此类订阅不得扩展到第三方 app 或服务。订阅必须适用于可使用该 app 的所有用户设备。进一步了解<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Subscriptions.html" target="_blank" rel="noopener">在您的 app 之间共享订阅</a>。<br>App 不得强制要求用户为 app 评级或点评、下载其他 app，或执行其他类似操作，然后才能访问该 app 的功能、内容或者使用该 app。<br>与所有 app 一样，此类服务订阅应当允许用户直接获得付费购买的项目而无需执行额外任务，如在社交媒体上发帖、上传通讯录，以及在 app 内签到特定次数等。<br>订阅不得包含消耗性的积分和游戏内货币等，即使与其他服务相结合也不行，但您可以提供包含消耗性商品打折权益的订阅，例如能以优惠价购买宝石包的高级会员资格。<br>如果要将现有 app 更改为基于订阅的业务模式，您不得减掉现有用户已付费购买的主要功能。例如，针对新客户引入订阅模式后，已购买“完整游戏解锁”的客户应能够继续访问完整版游戏。</p>
<p><strong>3.1.2(b) 升级和降级：</strong>用户应能获得无缝的升级/降级体验，并且不会出现无意间订阅同一内容的多个不同版本。请查阅关于管理订阅升级和降级选项的<a href="https://developer.apple.com/app-store/subscriptions/" target="_blank" rel="noopener">最佳做法</a>。<br><strong>3.1.2(c) 订阅信息：</strong>在让客户订阅之前，您应当清晰描述付费后的具体权益。每月有几期？云存储容量有多大？具体能访问您的哪些服务？另外，务必要清晰地表述相关的要求，即您协议的 Schedule 2 中“<a href="http://www.apple.com/itunes/go/itunesconnect/contracts" target="_blank" rel="noopener">Agreements, Tax, and Banking</a>”部分所述的要求。<br><strong>3.1.3 基于内容的“阅读器”App：</strong>App 应允许用户访问先前购买的内容或内容订阅（具体而言是：杂志、报纸、图书、音频、音乐、视频、专业数据库访问权限、VoIP、云存储以及经批准的服务，如用于管理学生成绩和课表的教育类 App），前提是 app 不得引导用户使用非 IAP 机制进行购买。<br><strong>3.1.4 内容代码：</strong>App 不得使用自身机制来解锁内容或功能，如许可证密钥、增强现实标记、二维码等。在为数不多的情形中，例如当功能依赖于特定的硬件功能时，App 可在不使用 App 内购买的情况下解锁该功能（例如，天文 App 会在与望远镜同步后增加功能）。与经过批准的实际产品（如玩具）配合使用的<em>可选</em> App 功能可在不使用 IAP 的情况下解锁特定功能，前提是同时也提供 IAP 选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁 App 功能。<br><strong>3.1.5 App 之外的实物商品和服务：</strong>如果 app 允许用户购买将在 app 之外使用的商品或服务，则必须使用 IAP 以外的购买方式来收取相应款项，如 Apple Pay 或传统的信用卡入口。App 可支持获批虚拟货币的流通（如比特币、狗币），前提条件是，在该 app 能够正常使用的地区，前述做法必须遵守各州法律和联邦法律。<br><strong>3.1.6 Apple Pay：</strong>如果 app 使用 Apple Pay，则在销售任何商品或服务之前，必须先向用户提供所有的基本购买信息，并且必须正确使用 Apple Pay 品牌和用户界面元素，具体要求可参考“<a href="https://developer.apple.com/apple-pay/Apple-Pay-Identity-Guidelines-CN.pdf" target="_blank" rel="noopener">Apple Pay 识别标志指南</a>”和“<a href="https://developer.apple.com/ios/human-interface-guidelines/technologies/apple-pay/" target="_blank" rel="noopener">Human Interface Guidelines</a>”。使用 Apple Pay 提供重复付款服务的 App 至少需要披露以下信息：续订周期的时长；除非被取消，否则续订将会继续<br>每个周期中会提供哪些服务<br>将向客户收取的实际费用<br>如何取消</p>
<p><strong>3.2 其他业务模式问题</strong>下方列表并非详尽清单，并且您提交的 App 可能会导致我们的政策有所更改或更新，但这里有一些额外的应做事宜和勿做事宜需要您谨记在心：<br><strong>3.2.1 可以接受**</strong>(i)<strong> 在您的 App 中，出于购买或促销目的而展示您的其他 App，只要您的 App 不只是简单地罗列其他 App。
</strong>(ii)<strong> 显示或推荐专为经批准的特定需求而设计的第三方 App（如健康管理、航空以及辅助功能等）。您的 App 应能提供持续不断的编辑内容，这样 App 看起来才不会只像是个摆设。
</strong>(iii)<strong> 在租借期限结束后，禁止访问经批准的特定租借内容（例如电影、电视节目、音乐、图书）；所有其他项目服务不得存在过期时间。
</strong>(iv)<strong> Wallet 凭证可用于付款或接收付款、传输交易或是提供身份验证（例如电影票、优惠券和 VIP 凭据）。如将 Wallet 凭证用作其他用途，则可能会导致 App 被拒，Wallet 凭据也有可能被撤消。
</strong>(v)** 保险类 App 必须免费提供，并且必须遵守 App 发布地区的相关法律，且不得使用 IAP。</p>
<p><strong>3.2.2 不可接受**</strong>(i)<strong> 创建与 App Store 类似且用于显示第三方 App、扩展功能或插件的界面，或将其作为热门 App 的合集。
</strong>(ii)<strong> 通过由硬件或操作系统提供的内置功能（诸如推送通知、照相机或陀螺仪）或 Apple 服务（如 Apple Music 访问或 iCloud 存储）获利。
</strong>(iii)<strong> 人为地刷广告展示次数或者广告点进次数的 App，以及主要设计目的在于显示广告的 App。
</strong>(iv)<strong> 在 App 内为慈善组织和募集资金者收集资金。出于以上目的筹集资金的 App 必须在 App Store 上免费，并只能在 App 之外筹集，例如通过 Safari 或短信。
</strong>(v)<strong> 强行限制 App 的用户群，例如限制特定地区或运营商。
</strong>(vi) **App 应当允许用户直接获得付费购买的项目而无需执行额外的任务，如在社交媒体上发帖、上传通讯录，以及在 app 内签到特定次数等。App 不得强制要求用户为 app 评级或点评、下载其他 app 或执行其他类似操作，然后才能访问该 app 的功能、内容或者使用该 app。</p>
<ol start="4">
<li>设计<br>Apple 客户非常注重简洁、雅致、创新且易于使用的产品，这也正是我们希望在 App Store 上看到的。您可尽情提供各种优秀设计，但要想获准在 App Store 上发布 app，至少需要满足以下标准。另请记住，即使在 app 获得批准之后，您也应当对其进行更新，确保 app 功能正常并持续吸引新客户和现有客户。停止服务或体验下降的 app 随时可能会从 App Store 中移除。<br><strong>4.1 抄袭者</strong>请拿出您自己的想法。我们知道您有自己的奇思妙想，那么请将它们付诸实际。请不要简单照搬 App Store 上的热门 App，或只是细微修改其他 App 的名称或 UI，就将其挪为己用。这么做不但有引发知识产权侵权索赔的风险，更会加剧在 App Store 中浏览的难度，并对您的开发者同仁来说也很不公平。</li>
</ol>
<p>4.2 <strong>最低功能要求</strong>App 应包含功能、内容和 UI，而不仅仅是一个经过重新包装的网站。如果 App 没有什么实用价值、毫无新意或者不太像是一个 App，那它就不适合出现在 App Store 中。如果 App 不能带来持久的娱乐价值，或只是让人感到毛骨悚然，则无法获得批准。如果 App 只是一首歌曲或一部影片，则应提交到 iTunes Store。如果 App 只是一本书籍或游戏指南，则应提交到 iBooks Store。<br><strong>4.2.1</strong> App 应该为实现预期用途而使用 API 和框架，并在 App 描述中说明集成详情。例如，HomeKit 框架应提供家居自动化服务，HealthKit 则应该用于保持健康和健身目的，并集成在“健康”App 中。<br><strong>4.2.2</strong> 除了那些属于特定类型的 App 之外，App 不应只用于市场营销材料、广告、网络剪报、内容聚合或链接集合。<br><strong>4.2.3</strong> App 应能独立工作，无需安装其他 App。<br><strong>4.2.4</strong> 与表盘类似的 Apple Watch App 可能会令人感到困惑，因为用户会认为这些 App 能与各种设备功能（如轻扫、通知和第三方功能栏）配合使用。将创意性的时间表现方式用作 App 界面是个好点子（例如，供冲浪者使用的潮汐时钟），但是如果您的 App 与表盘过于相像，则可能会被我们拒绝。<br><strong>4.2.5</strong> 主要用作 iCloud 和 iCloud Drive 文件管理器的 App 需要包含其他应用功能，才能获得批准。</p>
<p><strong>4.3 垃圾 App</strong>请不要为同一个 App 创建多个套装 ID。如果您的 App 针对特定位置、运动队、大学等存在不同版本，请考虑提交单个 App，并提供 App 内购买以提供差异功能。同时，请避免继续在已有大量类似 App 的类别下进行开发；App Store 上已经有太多模拟放屁、打嗝声音的 app，以及手电筒和爱经 app。上传大量相似版本 App 的开发者会遭到 Apple Developer Program 的除名。</p>
<p><strong>4.4 扩展功能</strong>托管或包含扩展功能的 App 必须遵循“<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="noopener">App Extension Programming Guide”</a>或“<a href="https://developer.apple.com/library/content/documentation/Tools/Conceptual/SafariExtensionGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Safari Extensions Development Guide</a>”，如果可行，还应包含诸如帮助屏幕和设置界面在内的一系列功能。您应当在 app 的市场营销文本中清晰且准确地披露提供哪些扩展功能。<br><strong>4.4.1</strong> 键盘扩展功能还需要遵循一些额外的规则。它们必须：<br>提供键盘输入功能（如可输入字符）；<br>提供切换到下一个键盘的方法；<br>在没有网络连接的情况下仍能使用：<br>按照“<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="noopener">App Extension Programming Guide</a>”所述提供数字和十进制键盘类型；<br>收集用户活动数据只是为了改进其键盘扩展功能在 iOS 设备上的性能。</p>
<p>它们不得：<br>包含市场营销、广告或 App 内购买；<br>启动“设置”之外的其他 app；或者<br>将键盘按键用于其他行为，例如按住 Return 键来启动相机等。</p>
<p><strong>4.4.2</strong> Safari Extension 必须在 OS X 上的最新版 Safari 上运行。它们不得干扰系统和 Safari UI 元素，并绝不能包含恶意或误导性的内容或代码。违背此规则会遭到 Apple Developer Program 除名。除了正常工作所必需的网站，Safari Extension 不得要求访问更多网站。<br><strong>4.4.3</strong> 表情贴纸表情贴纸是让“信息”变得更动态、更有趣的绝佳方式，让人们能够以更巧妙、有趣、有意义的方式表达自我。无论您的 app 含有表情贴纸扩展，还是您要创建单独的表情贴纸包，其内容均不得冒犯用户、造成负面体验或违反相关法律。<br><strong>(i)</strong> 通常，不适合在 App Store 上发布的内容也不适合放入表情贴纸内。<br><strong>(ii)</strong> 考虑地区敏感性，不要在难以接受或者会违反当地法律的国家/地区提供您的表情贴纸包。<br><strong>(iii)</strong> 如果您的表情贴纸含义不易理解，请在审核备注中附上清晰的说明，从而避免导致审核流程的延误。<br><strong>(iv)</strong> 确保您的表情贴纸在您的朋友与家人之外具有相关性；它们不应特定于个人活动、群体或关系。<br><strong>(v)</strong> 您必须对表情贴纸中的内容，持有所有必要的著作权、商标权和形象权及授权许可，不得提交任何未经授权的内容。请记住，您必须能够在要求时提供可核实的文件。若 app 内含有您无权使用的表情贴纸内容，该 app 将从 App Store 中去除，屡次侵权者将从 Developer Program 中除名。如果您认为自己的内容遭到其他提供商侵权，请<a href="https://www.apple.com/legal/internet-services/itunes/appstorenotices/#?lang=zh" target="_blank" rel="noopener">在此处提交索赔</a>。</p>
<p><strong>4.5 Apple 站点和服务**</strong>4.5.1<strong> App 可以使用获批的 Apple RSS Feed，例如 iTunes Store RSS Feed，但不能抹除 Apple 站点（如 apple.com、iTunes Store、App Store、iTunes Connect、开发者门户等）的任何信息，或是使用此信息进行排名。
</strong>4.5.2<strong> 在使用您的 App 时，客户可以通过 Apple Music API 访问他们的订阅。用户必须启动流功能，并能使用标准媒体控件（如“播放”、“暂停”和“跳过”）来进行播放；App 可能不会自动执行这些操作。此外，您的 App 不得要求用户通过付款或间接的货币化方式来获取 Apple Music 服务的访问权限（如 App 内购买、广告、需要用户信息）。
</strong>4.5.3<strong> 不得使用 Apple 服务（包括 Game Center 或推送通知等）发送垃圾邮件、进行网络钓鱼，或者向客户发送未经请求的信息。不得尝试进行查找、跟踪、关联、挖掘、获得或利用玩家 ID、别名以及通过 Game Center 获得的其他信息。如果这么做，将会遭到 Apple Developer Program 的除名。
</strong>4.5.4<strong> App 不能将推送通知列为必需条件，并不能将该功能用于广告、推广或直接行销用途，或者用来发送敏感的个人或保密信息。
</strong>4.5.5** 仅以 Game Center 团队批准的方式使用 Game Center 玩家 ID，并不得在 App 中显示或向任何第三方显示。</p>
<ol start="5">
<li>法律<br>只要 App 向某个地区的用户提供，那么就必须遵守该地区的所有法律要求（如果您不太确定，请与律师联系）。我们知道这些东西非常复杂，但理解所有本地法律，并确保您的 App 能满足所有法律要求，而不仅仅是下方列出的准则，是您必须承担的责任。当然，如果 App 存在唆使、宣传或鼓励犯罪的行为或明显不负责任的行为，则会被拒绝。<br><strong>5.1 隐私</strong>在 Apple 生态体系中，保护用户隐私总是第一要务。您要在处理个人数据时小心谨慎，以确保遵守了适用的法律和“<a href="https://developer.apple.com/terms/" target="_blank" rel="noopener">Apple Developer Program 许可协议</a>”中的条款，并满足客户的期待。尤其是：<br><strong>5.1.1 数据收集和存储**</strong>(i)<strong> 如果 app 会收集用户信息或使用数据，其内必须制定隐私政策，并征得用户的同意才能收集。这包括（但不限于）以下 app：实施 HealthKit 或其他健康/医疗技术、HomeKit、键盘扩展功能、Apple Pay、表情贴纸和 iMessage 扩展功能的 app；包含登录信息的 app；或访问设备上用户数据（例如位置、通讯录、日历等）的 app。
</strong>(ii)<strong> 如果 app 不包含基于帐户的重要功能，请允许用户在不登录的情况下使用。App 不得要求用户提供个人信息才能正常使用，除非个人信息与 app 的核心功能直接相关，或是法律要求时。如果您的核心 app 功能与特定的社交网络（如 Facebook、微信、微博或 Twitter 等）不相关，您必须提供无需登录或其他类似机制的访问权限。调取基本档案信息、分享到社交网络或邀请朋友使用 app 等不视为核心 app 功能。
</strong>(iii)<strong> 如果开发者开发的 app 试图暗中收集用户密码或其他用户私人数据，那么该开发者会遭到 Apple Developer Program 的除名。
</strong>(iv)** 必须使用 SafariViewController 在显著位置向用户显示信息；不得隐藏该控制器，也不能被其他视图或图层遮挡。此外，未经用户的知情和同意，app 不得私下利用 SafariViewController 来跟踪用户。</li>
</ol>
<p><strong>5.1.2 数据使用和共享**</strong>(i)<strong> 如果在未先获得用户的许可，并提供有关数据使用方式和使用位置的相关信息，则 app 不能使用或传输用户的个人数据。
</strong>(ii)<strong> App 收集的数据只有在为了改进与 App 功能相关的用户体验或软/硬件表现时，或在遵循“<a href="https://developer.apple.com/terms/" target="_blank" rel="noopener">Apple Developer Program 许可协议</a>”的前提下用于广告投放用途时，才能使用或与第三方分享。
</strong>(iii)<strong> 从 HomeKit API 收集的数据不得用于投放广告或是基于使用情况进行其他数据挖掘。
</strong>(iv)** 使用 Apple Pay 的 App 只能与第三方共享通过 Apple Pay 获得的用户数据，以帮助或改进商品或服务的交付。</p>
<p><strong>5.1.3 健康和健康研究</strong>健康、健身和医疗数据特别敏感，涵盖这些领域的 App 必须满足额外的规则，并确保客户隐私受到保护：<br><strong>(i)</strong> App 仅能在获得批准的情况下，出于改进健康管理或健康研究的目的，使用在健康、健身和医疗研究背景下收集的数据（包括从 HealthKit API、“运动与健身”或健康领域人体研究中收集的数据）或将其披露给第三方，不得用于广告投放或基于使用情况进行其他数据挖掘。<br><strong>(ii)</strong> App 不得将虚假或错误数据写入 HealthKit 或其他任何医疗研究/健康管理 App，不得在 iCloud 中存储个人健康信息。<br><strong>(iii)</strong> 开展健康领域人体研究的 App 必须获得参与人员提供的知情同意书，如果涉及未成年人，则必须获得由其家长或监护人提供的知情同意书。上述知情同意书必须涵盖以下内容：(a) 研究的性质、目的和时长；(b) 具体规程，给参与人员带来的风险和益处；(c) 关于保密和数据处理（包括与第三方共享信息的情况）的信息；(d) 用于回答参与人员问题的联系人；以及 (e) 退出流程。<br><strong>(iv)</strong> 用于开展健康领域人体研究的 App 必须获得一家独立伦理审查委员会的批准。一经要求，必须提供此类批准的证明。</p>
<p><strong>5.1.4 儿童</strong>出于多种原因，您在处理儿童的个人数据时必须小心谨慎。我们建议您仔细阅读所有要求，以遵循相关法律，如《儿童在线隐私保护法》（“COPPA”）和其他国际上适用的同等法律。<br>App 只能出于遵守适用儿童隐私法规的目的要求用户提供出生日期或家长联系信息，但必须提供一些适用于各年龄层用户的实用功能或娱乐价值。<br>此外，“儿童类别”中的 App，以及向未成年人收集个人信息（例如姓名、地址、电子邮件、位置、照片、视频、图画、能否聊天、其他个人数据，或是将永久标识符与以上任何信息组合使用）、传输此类信息或能够共享此类信息的 App，则必须遵守适用的儿童隐私保护法规，且必须拥有隐私政策。为了清楚起见，“儿童类别”的<a href="https://developer.apple.com/app-store/review/guidelines/cn/#kids-category" target="_blank" rel="noopener">家长监控要求</a>，通常并不完全等同于在这些隐私法规下征得家长的同意后收集个人数据。</p>
<p><strong>5.1.5 定位服务</strong>只有在定位服务与 App 提供的功能和服务直接相关时，才能在 App 中使用定位服务。基于位置的 API 不得用于提供紧急服务，不得对汽车、飞机和其他设备进行自主控制（小型设备，如轻量无人机和玩具除外），不得遥控汽车防盗系统等。在收集、传输或使用位置数据之前，务必进行通知并获得用户同意。如果 App 会使用后台定位服务，请务必在 App 中说明相应的原因；请参考“<a href="https://developer.apple.com/ios/human-interface-guidelines/interaction/requesting-permission/" target="_blank" rel="noopener">Human Interface Guidelines</a>”，了解相应的最佳做法。</p>
<p><strong>5.2 知识产权￼</strong>请确保 App 只包含由您创建或拥有使用许可的内容。如果您已越线并在未经许可的情况下使用了内容，您的 App 可能会被移除。当然，这也意味着如果他人抄袭了您的作品，则他们的 App 也可能会被移除。如果您认为自己的知识产权在 App Store 上受到了其他开发者的侵犯，请通过<a href="http://www.apple.com/legal/internet-services/itunes/appstorenotices/" target="_blank" rel="noopener">网络表单￼</a>提交权利主张。各个国家/地区的法律互不相同，但请务必避免以下常见错误：<br><strong>5.2.1</strong> 一般性：不得在未经许可的情况下，在 App 中使用受保护的第三方材料（例如商标、版权作品、专利设计），或在 App 套装中包含虚假、抄袭或误导性的演示、名称或元数据。<br><strong>5.2.2</strong> 第三方站点/服务：如果您的 App 会使用、访问第三方服务、通过访问第三方服务盈利或是显示第三方服务的内容，请确保您获得在该服务的使用条款下进行此类操作的特别许可。如有相应要求，则必须提供相关授权。<br><strong>5.2.3</strong> 音频/视频下载：App 不得促进非法文件共享，或在没有获得这些资源的明确授权的情况下，提供从第三方来源（如 Apple Music、YouTube、SoundCloud、Vimeo）保存、转换或下载媒体资源的能力。视频/音频内容流也有可能触犯使用条款，所以请务必在 App 访问这些服务前，进行检查。如有相应要求，则必须提供相关文稿。<br><strong>5.2.4</strong> Apple 背书：不得误导或暗示 Apple 是 App 的来源或提供商，或者 Apple 以任何形式表示认可其质量或功能。如果您的 App 被选为“编辑选荐”，Apple 将自动显示相应徽章。<br><strong>5.2.5</strong> Apple 产品：不得创建与现有 Apple 产品、界面（如 Finder）、App（如 App Store、iTunes Store 或“信息”）或广告主题外观相似或容易混淆的 App，请勿拼错 Apple 产品的名称（如 Iphone 版 GPS、iTunz）。iTunes 音乐预览内容不得用于其娱乐价值（如用作照片拼贴画的背景音乐或游戏配音）或其他未获授权的方式。如果 App 显示健身记录圆环，请不要修改圆环本身的观感，以及其代表的数据。“<a href="https://developer.apple.com/watch/human-interface-guidelines/ui-elements/#activity-rings" target="_blank" rel="noopener">Human Interface Guidelines</a>”中含有有关如何使用健身记录圆环的更多信息。</p>
<p><strong>5.3 游戏、赌博和彩票</strong>游戏、赌博和彩票的管理难度大，是 App Store 上受到最多管制的应用类别之一。只有全面核实了即将发布您 App 的所有国家/地区的相关法律要求后，才能包含此功能，并且要做好准备此功能的审核流程需要更长的时间。您需要谨记以下事项：<br><strong>5.3.1</strong> 抽奖和比赛必须由 App 的开发者赞助。<br><strong>5.3.2</strong> 抽奖、比赛和抽彩的正式规则必须在 App 中注明，并且必须明确表示 Apple 不是赞助者，也没有以任何形式参与活动。<br><strong>5.3.3</strong> App 不得通过 IAP 购买点数或货币，以用于任何种类的真实货币游戏；不得向用户出售彩票或抽彩券；不得在 App 内进行资金转账。<br><strong>5.3.4</strong> 提供真实货币游戏（例如体育下注、扑克、赌场游戏、赛马）或彩票的 App 必须在使用该 App 的地区获得必要的许可和批准，且只能在这些地区发布，此类 App 在 App Store 中必须免费提供。不允许在 App Store 上发布非法的赌博辅助工具，包括记牌器。彩票 App 必须有报酬、几率及奖品。</p>
<p>提交之后<br>在 iTunes Connect 中提交 App 和元数据之后，您随即就会进入审核流程。请谨记以下几点：<br><strong>时间安排：</strong>App Review 团队将尽快检查您的 App，而且我们一直在力求缩短审核时间。进一步了解 <a href="https://developer.apple.com/support/app-review/cn/" target="_blank" rel="noopener">App Review</a>。<br><strong>状态更新</strong>：App 的当前状态会反映在 iTunes Connect 中，所以请多留意此处。<br><strong>加急请求</strong>：如果您遇到了严重的时间问题，可以<a href="https://developer.apple.com/contact/app-store/?topic=expedite" target="_blank" rel="noopener">申请加快审核</a>。请仅在您真的需要加快审核时才提出申请，以便其他开发者的加急请求不受影响。如果我们发现您滥用此系统，从此以后我们可能都会拒绝您的申请。<br><strong>发布日期</strong>：如果您设定了未来的发布日期，在此日到来之前，即使已经获得了 App Review 团队的批准，App 也不会显示在 App Store 上。请注意，最多可能需要 24 小时时间，您的 App 才能显示在所有选定的商店中。<br><strong>拒绝</strong>：我们的目标是公平、持续地遵循这些准则，但是人无完人。如果您的 App 被拒绝，但您存在疑问，或希望提供其他信息，请使用解决方案中心，以与 App Review 团队直接沟通。这样可以帮助您的 App 出现在商店中，也可帮助我们改进 App Review 流程，并在我们的政策中发现需要阐明的部分。如果您仍对结果不满意，请<a href="https://developer.apple.com/contact/app-store/?topic=appeal" target="_blank" rel="noopener">提交申诉</a>。</p>
<p>我们期待看到您开发出更多优秀作品！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/App-Store-审核指南/" data-id="cjgdiqq6w0006keziiwoxjqie" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-JavaScriptCore使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-JavaScriptCore使用/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-JavaScriptCore使用/">iOS-JavaScriptCore使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScriptCore是apple推出的为了解决ios与js交互的框架，功能强大而实用。</p>
<p>##JavaScriptCore中主要的类</p>
<p> 1、JSContext — 在OC中创建JavaScript运行的上下文环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init; // 创建JSContext对象，获得JavaScript运行的上下文环境</span><br><span class="line"></span><br><span class="line">// 在特定的对象空间上创建JSContext对象，获得JavaScript运行的上下文环境</span><br><span class="line">- (instancetype)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine;</span><br><span class="line"></span><br><span class="line">// 运行一段js代码，输出结果为JSValue类型</span><br><span class="line">- (JSValue *)evaluateScript:(NSString *)script;</span><br><span class="line"></span><br><span class="line">// iOS 8.0以后可以调用此方法</span><br><span class="line">- (JSValue *)evaluateScript:(NSString *)script withSourceURL:(NSURL *)sourceURL NS_AVAILABLE(10_10, 8_0);</span><br><span class="line"></span><br><span class="line">// 获取当前正在运行的JavaScript上下文环境</span><br><span class="line">+ (JSContext *)currentContext;</span><br><span class="line"></span><br><span class="line">// 返回结果当前执行的js函数 function () &#123; [native code] &#125; ，iOS 8.0以后可以调用此方法</span><br><span class="line"> + (JSValue *)currentCallee NS_AVAILABLE(10_10, 8_0);</span><br><span class="line"></span><br><span class="line"> // 返回结果当前方法的调用者[object Window]</span><br><span class="line"> + (JSValue *)currentThis;</span><br><span class="line"></span><br><span class="line"> // 返回结果为当前被调用方法的参数</span><br><span class="line"> + (NSArray *)currentArguments;</span><br><span class="line"></span><br><span class="line"> // js的全局变量 [object Window]</span><br><span class="line"> @property (readonly, strong) JSValue *globalObject;</span><br></pre></td></tr></table></figure></p>
<p> 2、JSValue — JavaScript中的变量和方法，可以转成OC数据类型,每个JSValue都和JSContext相关联并且强引用context<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">   oc与js类型对照：</span><br><span class="line">      @textblock</span><br><span class="line">     Objective-C type  |   JavaScript type</span><br><span class="line">   --------------------+---------------------</span><br><span class="line">           nil         |     undefined</span><br><span class="line">          NSNull       |        null</span><br><span class="line">         NSString      |       string</span><br><span class="line">         NSNumber      |   number, boolean</span><br><span class="line">       NSDictionary    |   Object object</span><br><span class="line">         NSArray       |    Array object</span><br><span class="line">          NSDate       |     Date object</span><br><span class="line">         NSBlock (1)   |   Function object (1)</span><br><span class="line">            id (2)     |   Wrapper object (2)</span><br><span class="line">          Class (3)    | Constructor object (3)</span><br><span class="line">      @/textblock</span><br><span class="line"></span><br><span class="line">  //此方法会转换self为JS对象，但是self中必须实现指定的方法和协议</span><br><span class="line">  + (JSValue *)valueWithObject:(id)value inContext:(JSContext *)context;</span><br><span class="line"></span><br><span class="line">  // 在context创建BOOL的JS变量</span><br><span class="line">  + (JSValue *)valueWithBool:(BOOL)value inContext:(JSContext *)context;</span><br><span class="line"></span><br><span class="line">  // 将JS变量转换成OC中的BOOL类型</span><br><span class="line">  - (BOOL)toBool;</span><br><span class="line"></span><br><span class="line">  // 修改JS对象的属性的值</span><br><span class="line">  - (void)setValue:(id)value forProperty:(NSString *)property;</span><br><span class="line"></span><br><span class="line">  // JS中是否有这个对象</span><br><span class="line">  @property (readonly) BOOL isUndefined;</span><br><span class="line"></span><br><span class="line">  // 比较两个JS对象是否相等</span><br><span class="line">  - (BOOL)isEqualToObject:(id)value;</span><br><span class="line"></span><br><span class="line">  // 调用者JSValue为JS中的方法，arguments为参数，执行调用者JSValue，并传递参数arguments,@[@&quot;a&quot;,@&quot;b&quot;@&quot;c&quot;]</span><br><span class="line">  - (JSValue *)callWithArguments:(NSArray *)arguments;</span><br><span class="line"></span><br><span class="line"> // 调用者JSValue为JS中的全局对象名称，method为全局对象的方法名称，arguments为参数</span><br><span class="line">  - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments;</span><br><span class="line"></span><br><span class="line"> // JS中的结构体类型转换为OC</span><br><span class="line">  + (JSValue *)valueWithPoint:(CGPoint)point inContext:(JSContext *)context;</span><br><span class="line">JSExport --- JS调用OC中的方法和属性写在继承自JSExport的协议当中，OC对象实现自定义的协议</span><br><span class="line"> // textFunction -- JS方法</span><br><span class="line"> // - (void) ocTestFunction:(NSNumber *)value sec:(NSNumber *)number -- OC方法</span><br><span class="line"> JSExportAs (textFunction,- (void) ocTestFunction:(NSNumber *)value sec:(NSNumber *)number);</span><br><span class="line">JSManagedValue --- JS和OC对象的内存管理辅助对象,主要用来保存JSValue对象,解决OC对象中存储js的值，导致的循环引用问题</span><br><span class="line"></span><br><span class="line"> JSManagedValue *_jsManagedValue = [JSManagedValue managedValueWithValue:jsValue];</span><br><span class="line">[_context.virtualMachine addManagedReference:_jsManagedValue];</span><br><span class="line">JSManagedValue本身只弱引用js值，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine中，这样如果JavaScript能够找到该JSValue的Objective-C owner，该JSValue的引用就不会被释放。</span><br><span class="line">JSVirtualMachine --- JS运行的虚拟机，有独立的堆空间和垃圾回收机制，运行在不同虚拟机环境的JSContext可以通过此类通信。</span><br></pre></td></tr></table></figure></p>
<p>下面记录一下使用方法：</p>
<p>##一、简单的情况，JS中，点击事件直接调用方法方式<br>   1.1 JS代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body style=&quot;background-color: white;&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var nativeCallJS = function(parameter) &#123;</span><br><span class="line">            alert (parameter);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;jsCallNative(&apos;jsParameter&apos;)&quot; style=&quot;width:100%; height:30px;&quot;/&gt;调用OC代码&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>1.2 oc代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)doSomeJsThings&#123;</span><br><span class="line">    </span><br><span class="line">    self.jsContext = [_webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        NSLog(@&quot;出现异常，异常信息：%@&quot;,exception);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //oc调用js</span><br><span class="line">    JSValue * nativeCallJS = self.jsContext[@&quot;nativeCallJS&quot;];</span><br><span class="line">    [nativeCallJS callWithArguments:@[@&quot;hello word&quot;]];//调用了js中方法&quot;nativeCallJS&quot;,并且传参数@&quot;hello word&quot;</span><br><span class="line">    </span><br><span class="line">    //在本地生成js方法，供js调用</span><br><span class="line">    self.jsContext[@&quot;jsCallNative&quot;] = ^(NSString *paramer)&#123;</span><br><span class="line">        JSValue *currentThis = [JSContext currentThis];</span><br><span class="line">        JSValue *currentCallee = [JSContext currentCallee];</span><br><span class="line">        NSArray *currentParamers = [JSContext currentArguments];</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            /**</span><br><span class="line">             *  js调起OC代码，代码在子线程，更新OC中的UI，需要回到主线程</span><br><span class="line">             */</span><br><span class="line">            NSLog(@&quot;js传过来：%@&quot;,paramer);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;JS paramer is %@&quot;,paramer);</span><br><span class="line">        NSLog(@&quot;currentThis is %@&quot;,[currentThis toString]);</span><br><span class="line">        NSLog(@&quot;currentCallee is %@&quot;,[currentCallee toString]);</span><br><span class="line">        NSLog(@&quot;currentParamers is %@&quot;,currentParamers);</span><br><span class="line">    &#125;;//生成native的js方法，方法名：@&quot;jsCallNative&quot;,js可直接调用此方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2017-11-15 13:30:37.715810+0800 WebView+image[2940:337555] js传过来：jsParameter</span><br><span class="line">2017-11-15 13:30:37.715759+0800 WebView+image[2940:337892] JS paramer is jsParameter</span><br><span class="line">2017-11-15 13:30:37.716007+0800 WebView+image[2940:337892] currentThis is [object Window]</span><br><span class="line">2017-11-15 13:30:37.716337+0800 WebView+image[2940:337892] currentCallee is function () &#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;</span><br><span class="line">2017-11-15 13:30:37.716743+0800 WebView+image[2940:337892] currentParamers is (</span><br><span class="line">    jsParameter</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>以上就是简单的调用。</p>
<p>##二、复杂调用，JS中，点击事件等事件通过调用全局对象的方法调用方法，JS和Native代码的互调如下：<br>2.1 JS代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">&lt;body style=&quot;background-color: white;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        globalObject = new Object();</span><br><span class="line">        globalObject.name = 100;</span><br><span class="line">        globalObject.nativeCallJS = function (parameter) &#123;</span><br><span class="line">            alert (parameter);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;NativeObject.jsCallNative()&quot; style=&quot;width:100%; height:30px;&quot;/&gt;调用OC代码&lt;/button&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;NativeObject.shareString(&apos;jsParameter&apos;)&quot; style=&quot;width:100%; height:30px;&quot;/&gt;调用OC代码并传参数&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.2 oc代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//声明的协议，当前viewController必须遵守</span><br><span class="line">@protocol JSObjcDelegate &lt;JSExport&gt;</span><br><span class="line"></span><br><span class="line">- (void)jsCallNative;</span><br><span class="line">- (void)shareString:(NSString *)shareString;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//方法实现，在webViewDidFinishLoad中调用</span><br><span class="line">- (void)doSomeJsThings&#123;</span><br><span class="line">    </span><br><span class="line">    self.jsContext = [_webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        NSLog(@&quot;出现异常，异常信息：%@&quot;,exception);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //oc调用js</span><br><span class="line">    JSValue * jsObj = self.jsContext[@&quot;globalObject&quot;];//拿到js中要调用方法的全局对象</span><br><span class="line">    //jsObj执行其方法nativeCallJS</span><br><span class="line">    JSValue * returnValue = [jsObj invokeMethod:@&quot;nativeCallJS&quot; withArguments:@[@&quot;hello word&quot;]];</span><br><span class="line">   //调用了js中方法&quot;nativeCallJS&quot;,并且传参数@&quot;hello word&quot;,这里returnValue是调用之后的返回值，可能为nil</span><br><span class="line">    NSLog(@&quot;returnValue:%@&quot;,returnValue);</span><br><span class="line">    </span><br><span class="line">    //写法1</span><br><span class="line">    JSValue * jsCallNative = [JSValue valueWithObject:self inContext:self.jsContext];//此方法会转换self为JS对象，但是self中必须实现指定的方法和协议</span><br><span class="line">    self.jsContext[@&quot;NativeObject&quot;] = jsCallNative;</span><br><span class="line">    //写法2</span><br><span class="line">    //self.jsContext[@&quot;NativeObject&quot;] = self;</span><br><span class="line">    //注：写法1和写法2效果相同，推荐写法1，毕竟系统方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jsCallNative&#123;//在本地生成js方法，供js调用</span><br><span class="line">    </span><br><span class="line">    JSValue *currentThis = [JSContext currentThis];</span><br><span class="line">    JSValue *currentCallee = [JSContext currentCallee];</span><br><span class="line">    NSArray *currentParamers = [JSContext currentArguments];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        /**</span><br><span class="line">         *  js调起OC代码，代码在子线程，更新OC中的UI，需要回到主线程</span><br><span class="line">         */</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;currentThis is %@&quot;,[currentThis toString]);</span><br><span class="line">    NSLog(@&quot;currentCallee is %@&quot;,[currentCallee toString]);</span><br><span class="line">    NSLog(@&quot;currentParamers is %@&quot;,currentParamers);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)shareString:(NSString *)shareString&#123;//在本地生成js方法，供js调用</span><br><span class="line">    </span><br><span class="line">    JSValue *currentThis = [JSContext currentThis];</span><br><span class="line">    JSValue *currentCallee = [JSContext currentCallee];</span><br><span class="line">    NSArray *currentParamers = [JSContext currentArguments];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        /**</span><br><span class="line">         *  js调起OC代码，代码在子线程，更新OC中的UI，需要回到主线程</span><br><span class="line">         */</span><br><span class="line">        NSLog(@&quot;js传过来：%@&quot;,shareString);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;JS paramer is %@&quot;,shareString);</span><br><span class="line">    NSLog(@&quot;currentThis is %@&quot;,[currentThis toString]);</span><br><span class="line">    NSLog(@&quot;currentCallee is %@&quot;,[currentCallee toString]);</span><br><span class="line">    NSLog(@&quot;currentParamers is %@&quot;,currentParamers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印的log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-11-15 14:02:18.695352+0800 WebView+image[3257:377010] currentThis is [object SecondViewController]</span><br><span class="line">2017-11-15 14:02:18.695745+0800 WebView+image[3257:377010] currentCallee is function () &#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;</span><br><span class="line">2017-11-15 14:02:18.695936+0800 WebView+image[3257:377010] currentParamers is (</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2017-11-15 14:02:50.904847+0800 WebView+image[3257:376893] js传过来：jsParameter</span><br><span class="line">2017-11-15 14:02:50.904842+0800 WebView+image[3257:377010] JS paramer is jsParameter</span><br><span class="line">2017-11-15 14:02:50.905124+0800 WebView+image[3257:377010] currentThis is [object SecondViewController]</span><br><span class="line">2017-11-15 14:02:50.905607+0800 WebView+image[3257:377010] currentCallee is function () &#123;</span><br><span class="line">    [native code]</span><br><span class="line">&#125;</span><br><span class="line">2017-11-15 14:02:50.906052+0800 WebView+image[3257:377010] currentParamers is (</span><br><span class="line">    jsParameter</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>##三，特殊要求<br>  3.1 、JS中对象已经生成，需要OC生成对应的方法实现，JS去调用<br>JS代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">&lt;body style=&quot;background-color: white;&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        globalObject = new Object();</span><br><span class="line">        globalObject.name = 100;</span><br><span class="line">        globalObject.nativeCallJS = function (parameter) &#123;</span><br><span class="line">            alert (parameter);</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        var callBack = function(parameter)&#123;</span><br><span class="line">            alert(parameter);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;NativeObject.jsCallNative()&quot; style=&quot;width:100%; height:30px;&quot;/&gt;调用OC代码&lt;/button&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;NativeObject.shareString(&apos;jsParameter&apos;)&quot; style=&quot;width:100%; height:30px;&quot;/&gt;调用OC代码并传参数&lt;/button&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; onclick = &quot;globalObject.creatJSMethod(&apos;jsParameter&apos;)&quot; style=&quot;width:100%;height:30px;&quot;/&gt;oc生成JS方法&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上JS中globalObject对象已经存在，但是在没有实现creatJSMethod方法，在按钮”oc生成JS方法”却调用了此方法。<br>OC代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)doSomeJsThings&#123;</span><br><span class="line">    </span><br><span class="line">    self.jsContext = [_webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        NSLog(@&quot;出现异常，异常信息：%@&quot;,exception);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //oc调用js</span><br><span class="line">    JSValue * jsObj = self.jsContext[@&quot;globalObject&quot;];//拿到JS中已经存在的对象</span><br><span class="line">    //为jsObj对应的方法提供方法实现</span><br><span class="line">    jsObj[@&quot;creatJSMethod&quot;] = ^(NSString * parameter)&#123;</span><br><span class="line">        NSLog(@&quot;方法生成成功：%@&quot;,parameter);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-11-15 14:47:08.126160+0800 WebView+image[3661:435044] 方法生成成功：jsParameter</span><br><span class="line">``` </span><br><span class="line">3.2、oc重写js本地的方法，与生成一样，上面的代码：</span><br></pre></td></tr></table></figure></p>
<p> jsObj[@”creatJSMethod”] = ^(NSString * parameter){<br>    NSLog(@”方法生成成功：%@”,parameter);<br> };<br><code>`</code><br>既能生成，也能重写。</p>
<p>这些基本就是全部的情况了，当然还有一些线程问题等，等有需要再总结。</p>
<p>#####总结：<br>oc与js交互，先看js是调oc还是oc调用js，再看js中方法是全局方法还是全局属性方法（可能说的不是很准确）。清楚了这些就好实现了！！！</p>
<p><a href="http://www.jianshu.com/p/c988d9fe55f5" target="_blank" rel="noopener">iOS WKWebView与JS交互</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-JavaScriptCore使用/" data-id="cjgdiqq6x0007kezibsjs377b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发系列-让你的应用“动”起来--CALayer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS开发系列-让你的应用“动”起来--CALayer/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS开发系列-让你的应用“动”起来--CALayer/">iOS开发系列-让你的应用“动”起来--CALayer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#概览</p>
<p>在iOS中随处都可以看到绚丽的动画效果，实现这些动画的过程并不复杂，今天将带大家一窥iOS动画全貌。在这里你可以看到iOS中如何使用图层精简非交互式绘图，如何通过核心动画创建基础动画、关键帧动画、动画组、转场动画，如何通过UIView的装饰方法对这些动画操作进行简化等。在今天的文章里您可以看到动画操作在iOS中是如何简单和高效，很多原来想做但是苦于没有思路的动画在iOS中将变得越发简单：</p>
<blockquote>
<ul>
<li>CALayer:<ul>
<li>CALayer简介</li>
<li>CALayer常用属性</li>
<li>CALayer绘图</li>
</ul>
</li>
</ul>
</blockquote>
<p>#CALayer</p>
<h2 id="1-CALayer简介"><a href="#1-CALayer简介" class="headerlink" title="1. CALayer简介"></a>1. CALayer简介</h2><p>在介绍动画操作之前我们必须先来了解一个动画中常用的对象CALayer。CALayer包含在QuartzCore框架中，这是一个跨平台的框架，既可以用在iOS中又可以用在Mac OS X中。在使用Core Animation开发动画的本质就是将CALayer中的内容转化为位图从而供硬件操作，所以要熟练掌握动画操作必须先来熟悉CALayer。</p>
<p>使用Quartz 2D绘图时大家其实已经用到了CALayer，当利用drawRect:方法绘图的本质就是绘制到了UIView的layer（属性）中，可是这个过程大家在上一节中根本体会不到。但是在Core Animation中我们操作更多的则不再是UIView而是直接面对CALayer。下图描绘了CALayer和UIView的关系，在UIView中有一个layer属性作为根图层，根图层上可以放其他子图层，在UIView中所有能够看到的内容都包含在layer中：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-1436b711fc0fd157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<h2 id="2-CALayer常用属性"><a href="#2-CALayer常用属性" class="headerlink" title="2. CALayer常用属性"></a>2. CALayer常用属性</h2><p>在iOS中CALayer的设计主要是了为了内容展示和动画操作，CALayer本身并不包含在UIKit中，它不能响应事件。由于CALayer在设计之初就考虑它的动画操作功能，CALayer很多属性在修改时都能形成动画效果，这种属性称为“隐式动画属性”。但是对于UIView的根图层而言属性的修改并不形成动画效果，因为很多情况下根图层更多的充当容器的做用，如果它的属性变动形成动画效果会直接影响子图层。另外，UIView的根图层创建工作完全由iOS负责完成，无法重新创建，但是可以往根图层中添加子图层或移除子图层。</p>
<p>下表列出了CALayer常用的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th>说明</th>
<th style="text-align:center">是否支持隐式动画</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">anchorPoint</td>
<td>和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">backgroundColor</td>
<td>图层背景颜色</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">borderColor</td>
<td>边框颜色</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">borderWidth</td>
<td>边框宽度</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">bounds</td>
<td>图层大小</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">contents</td>
<td>图层显示内容，例如可以将图片作为图层内容显示</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">contentsRect</td>
<td>图层显示内容的大小和位置</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">cornerRadius</td>
<td>圆角半径</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">doubleSided</td>
<td>图层背面是否显示，默认为YES</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">frame</td>
<td>图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">hidden</td>
<td>是否隐藏</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">mask</td>
<td>图层蒙版</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">maskToBounds</td>
<td>子图层是否剪切图层边界，默认为NO</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">opacity</td>
<td>透明度 ，类似于UIView的alpha</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">position</td>
<td>图层中心点位置，类似于UIView的center</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">shadowColor</td>
<td>阴影颜色</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">shadowOffset</td>
<td>阴影偏移量</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">shadowOpacity</td>
<td>阴影透明度，注意默认为0，如果设置阴影必须设置此属性</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">shadowPath</td>
<td>阴影的形状</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">shadowRadius</td>
<td>阴影模糊半径</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">sublayers</td>
<td>子图层</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">sublayerTransform</td>
<td>子图层形变</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">transform</td>
<td>图层形变</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<ul>
<li>隐式属性动画的本质是这些属性的变动默认隐含了CABasicAnimation动画实现，详情大家可以参照Xcode帮助文档中“Animatable Properties”一节。</li>
<li>在CALayer中很少使用frame属性，因为frame本身不支持动画效果，通常使用bounds和position代替。</li>
<li>CALayer中透明度使用opacity表示而不是alpha；中心点使用position表示而不是center。</li>
<li>anchorPoint属性是图层的锚点，范围在（0~1,0~1）表示在x、y轴的比例，这个点永远可以同position（中心点）重合，当图层中心点固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合）</li>
</ul>
<p>为了进一步说明anchorPoint的作用，假设有一个层大小100*100，现在中心点位置（50,50），由此可以得出frame（0,0,100,100）。上面说过anchorPoint默认为（0.5,0.5），同中心点position重合，此时使用图形描述如图1；当修改anchorPoint为（0,0），此时锚点处于图层左上角，但是中心点poition并不会改变，因此图层会向右下角移动，如图2；然后修改anchorPoint为（1,1,），position还是保持位置不变，锚点处于图层右下角，此时图层如图3。<br><img src="http://upload-images.jianshu.io/upload_images/2647951-cab9986817414c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>下面通过一个简单的例子演示一下上面几个属性，程序初始化阶段我们定义一个正方形，但是圆角路径调整为正方形边长的一半，使其看起来是一个圆形，在点击屏幕的时候修改图层的属性形成动画效果（注意在程序中没有直接修改UIView的layer属性，因为根图层无法形成动画效果）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//  KCMainViewController.m</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define WIDTH 50</span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">[self drawMyLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 绘制图层</span><br><span class="line">-(void)drawMyLayer&#123;</span><br><span class="line">CGSize size=[UIScreen mainScreen].bounds.size;</span><br><span class="line">//获得根图层</span><br><span class="line">CALayer *layer=[[CALayer alloc]init];</span><br><span class="line">//设置背景颜色,由于QuartzCore是跨平台框架，无法直接使用UIColor</span><br><span class="line">layer.backgroundColor=[UIColor colorWithRed:0 green:146/255.0 blue:1.0 alpha:1.0].CGColor;</span><br><span class="line">//设置中心点</span><br><span class="line">layer.position=CGPointMake(size.width/2, size.height/2);</span><br><span class="line">//设置大小</span><br><span class="line">layer.bounds=CGRectMake(0, 0, WIDTH,WIDTH);</span><br><span class="line">//设置圆角,当圆角半径等于矩形的一半时看起来就是一个圆形</span><br><span class="line">layer.cornerRadius=WIDTH/2;</span><br><span class="line">//设置阴影</span><br><span class="line">layer.shadowColor=[UIColor grayColor].CGColor;</span><br><span class="line">layer.shadowOffset=CGSizeMake(2, 2);</span><br><span class="line">layer.shadowOpacity=.9;</span><br><span class="line">//设置边框</span><br><span class="line">//    layer.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">//    layer.borderWidth=1;</span><br><span class="line">//   设置锚点</span><br><span class="line">//    layer.anchorPoint=CGPointZero;</span><br><span class="line">[self.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark 点击放大</span><br><span class="line">-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">UITouch *touch=[touches anyObject];</span><br><span class="line">CALayer *layer=self.view.layer.sublayers[0];</span><br><span class="line">CGFloat width=layer.bounds.size.width;</span><br><span class="line">if (width==WIDTH) &#123;</span><br><span class="line">width=WIDTH*4;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">width=WIDTH;</span><br><span class="line">&#125;</span><br><span class="line">layer.bounds=CGRectMake(0, 0, width, width);</span><br><span class="line">layer.position=[touch locationInView:self.view];</span><br><span class="line">layer.cornerRadius=width/2;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-b3a99537419dce31.gif?imageMogr2/auto-orient/strip" alt=""></p>
<hr>
<h2 id="3-CALayer绘图"><a href="#3-CALayer绘图" class="headerlink" title="3. CALayer绘图"></a>3. CALayer绘图</h2><p>在使用Quartz 2D绘图时，当调用了UIView的drawRect:方法绘制图形、图像，这种方式本质还是在图层中绘制，但是这里会着重介绍一下如何直接在图层中绘图。在图层中绘图的方式跟原来基本没有区别，只是drawRect:方法是由UIKit组件进行调用，因此里面可以使用一些UIKit封装的方法进行绘图，而直接绘制到图层的方法由于并非UIKit直接调用因此只能用原生的Core Graphics方法绘制。</p>
<p>图层绘图有两种方法，不管使用哪种方法绘制完必须调用图层的setNeedDisplay方法（注意是图层的方法，不是UIView的方法，前面我们介绍过UIView也有此方法）</p>
<ol>
<li>通过图层代理drawLayer: inContext:方法绘制</li>
<li>通过自定义图层drawInContext:方法绘制</li>
</ol>
<p>###使用代理方法绘图<br>通过代理方法进行图层绘图只要指定图层的代理，然后在代理对象中重写<strong>-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</strong>方法即可。需要注意这个方法虽然是代理方法但是不用手动实现CALayerDelegate，因为CALayer定义中给NSObject做了分类扩展，所有的NSObject都包含这个方法。另外设置完代理后必须要调用图层的setNeedDisplay方法，否则绘制的内容无法显示。</p>
<p>下面的代码演示了在一个自定义图层绘制一张图像并将图像设置成圆形，这种效果在很多应用中很常见，如最新版的手机QQ头像就是这种效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  KCMainViewController.m</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define PHOTO_HEIGHT 150</span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation KCMainViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">//自定义图层</span><br><span class="line">CALayer *layer=[[CALayer alloc]init];</span><br><span class="line">layer.bounds=CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">layer.position=CGPointMake(160, 200);</span><br><span class="line">layer.backgroundColor=[UIColor redColor].CGColor;</span><br><span class="line">layer.cornerRadius=PHOTO_HEIGHT/2;</span><br><span class="line">//注意仅仅设置圆角，对于图形而言可以正常显示，但是对于图层中绘制的图片无法正确显示</span><br><span class="line">//如果想要正确显示则必须设置masksToBounds=YES，剪切子图层</span><br><span class="line">layer.masksToBounds=YES;</span><br><span class="line">//阴影效果无法和masksToBounds同时使用，因为masksToBounds的目的就是剪切外边框，而阴影效果刚好在外边框</span><br><span class="line">//    layer.shadowColor=[UIColor grayColor].CGColor;</span><br><span class="line">//    layer.shadowOffset=CGSizeMake(2, 2);</span><br><span class="line">//    layer.shadowOpacity=1;</span><br><span class="line">//设置边框</span><br><span class="line">layer.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layer.borderWidth=2;</span><br><span class="line">//设置图层代理</span><br><span class="line">layer.delegate=self;</span><br><span class="line">//添加图层到根图层</span><br><span class="line">[self.view.layer addSublayer:layer];</span><br><span class="line">//调用图层setNeedDisplay,否则代理方法不会被调用</span><br><span class="line">[layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark 绘制图形、图像到图层，注意参数中的ctx是图层的图形上下文，其中绘图位置也是相对图层而言的</span><br><span class="line">-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#123;</span><br><span class="line">//    NSLog(@&quot;%@&quot;,layer);//这个图层正是上面定义的图层</span><br><span class="line">CGContextSaveGState(ctx);</span><br><span class="line">//图形上下文形变，解决图片倒立的问题</span><br><span class="line">CGContextScaleCTM(ctx, 1, -1);</span><br><span class="line">CGContextTranslateCTM(ctx, 0, -PHOTO_HEIGHT);</span><br><span class="line">UIImage *image=[UIImage imageNamed:@&quot;photo.png&quot;];</span><br><span class="line">//注意这个位置是相对于图层而言的不是屏幕</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT), image.CGImage);</span><br><span class="line">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span><br><span class="line">//    CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">CGContextRestoreGState(ctx);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-983f8fbeb04c3dea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用代理方法绘制图形、图像时在drawLayer:inContext:方法中可以通过事件参数获得绘制的图层和图形上下文。在这个方法中绘图时所有的位置都是相对于图层而言的，图形上下文指的也是当前图层的图形上下文。</p>
<p>需要注意的是上面代码中绘制图片圆形裁切效果时如果不设置masksToBounds是无法显示圆形，但是对于其他图形却没有这个限制。原因就是当绘制一张图片到图层上的时候会重新创建一个图层添加到当前图层，这样一来如果设置了圆角之后虽然底图层有圆角效果，但是子图层还是矩形，只有设置了masksToBounds为YES让子图层按底图层剪切才能显示圆角效果。同样的，有些朋友经常在网上提问说为什么使用UIImageView的layer设置圆角后图片无法显示圆角，只有设置masksToBounds才能出现效果，也是类似的问题。</p>
<p><strong>扩展1–带阴影效果的圆形图片裁切</strong></p>
<p>如果设置了masksToBounds=YES之后确实可以显示图片圆角效果，但遗憾的是设置了这个属性之后就无法设置阴影效果。因为masksToBounds=YES就意味着外边框不能显示，而阴影恰恰作为外边框绘制的，这样两个设置就产生了矛盾。要解决这个问题不妨换个思路:使用两个大小一样的图层，下面的图层负责绘制阴影，上面的图层用来显示图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  KCMainViewController.m</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define PHOTO_HEIGHT 150</span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation KCMainViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">CGPoint position= CGPointMake(160, 200);</span><br><span class="line">CGRect bounds=CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">CGFloat cornerRadius=PHOTO_HEIGHT/2;</span><br><span class="line">CGFloat borderWidth=2;</span><br><span class="line">//阴影图层</span><br><span class="line">CALayer *layerShadow=[[CALayer alloc]init];</span><br><span class="line">layerShadow.bounds=bounds;</span><br><span class="line">layerShadow.position=position;</span><br><span class="line">layerShadow.cornerRadius=cornerRadius;</span><br><span class="line">layerShadow.shadowColor=[UIColor grayColor].CGColor;</span><br><span class="line">layerShadow.shadowOffset=CGSizeMake(2, 1);</span><br><span class="line">layerShadow.shadowOpacity=1;</span><br><span class="line">layerShadow.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layerShadow.borderWidth=borderWidth;</span><br><span class="line">[self.view.layer addSublayer:layerShadow];</span><br><span class="line">//容器图层</span><br><span class="line">CALayer *layer=[[CALayer alloc]init];</span><br><span class="line">layer.bounds=bounds;</span><br><span class="line">layer.position=position;</span><br><span class="line">layer.backgroundColor=[UIColor redColor].CGColor;</span><br><span class="line">layer.cornerRadius=cornerRadius;</span><br><span class="line">layer.masksToBounds=YES;</span><br><span class="line">layer.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layer.borderWidth=borderWidth;</span><br><span class="line">//设置图层代理</span><br><span class="line">layer.delegate=self;</span><br><span class="line">//添加图层到根图层</span><br><span class="line">[self.view.layer addSublayer:layer];</span><br><span class="line">//调用图层setNeedDisplay,否则代理方法不会被调用</span><br><span class="line">[layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark 绘制图形、图像到图层，注意参数中的ctx是图层的图形上下文，其中绘图位置也是相对图层而言的</span><br><span class="line">-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#123;</span><br><span class="line">//    NSLog(@&quot;%@&quot;,layer);//这个图层正是上面定义的图层</span><br><span class="line">CGContextSaveGState(ctx);</span><br><span class="line">//图形上下文形变，解决图片倒立的问题</span><br><span class="line">CGContextScaleCTM(ctx, 1, -1);</span><br><span class="line">CGContextTranslateCTM(ctx, 0, -PHOTO_HEIGHT);</span><br><span class="line">UIImage *image=[UIImage imageNamed:@&quot;photo.jpg&quot;];</span><br><span class="line">//注意这个位置是相对于图层而言的不是屏幕</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT), image.CGImage);</span><br><span class="line">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span><br><span class="line">//    CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">CGContextRestoreGState(ctx);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-0ce398f485925bea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###扩展2–图层的形变</p>
<p>从上面代码中大家不难发现使用Core Graphics绘制图片时会倒立显示，对图层的图形上下文进行了反转。在前一篇文章中也采用了类似的方法去解决这个问题，但是在那篇文章中也提到过如果直接让图像沿着x轴旋转180度同样可以达到正确显示的目的，只是当时的旋转靠图形上下文还无法绕x轴旋转。今天学习了图层之后，其实可以控制图层直接旋转而不用借助于图形上下文的形变操作，而且这么操作起来会更加简单和直观。对于上面的程序，只需要设置图层的transform属性即可。需要注意的是transform是CATransform3D类型，形变可以在三个维度上进行，使用方法和前面介绍的二维形变是类似的，而且都有对应的形变设置方法（如：CATransform3DMakeTranslation()、CATransform3DMakeScale()、CATransform3DMakeRotation()）。下面的代码通过CATransform3DMakeRotation()方法在x轴旋转180度解决倒立问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  形变演示</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define PHOTO_HEIGHT 150</span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation KCMainViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">CGPoint position= CGPointMake(160, 200);</span><br><span class="line">CGRect bounds=CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">CGFloat cornerRadius=PHOTO_HEIGHT/2;</span><br><span class="line">CGFloat borderWidth=2;</span><br><span class="line">//阴影图层</span><br><span class="line">CALayer *layerShadow=[[CALayer alloc]init];</span><br><span class="line">layerShadow.bounds=bounds;</span><br><span class="line">layerShadow.position=position;</span><br><span class="line">layerShadow.cornerRadius=cornerRadius;</span><br><span class="line">layerShadow.shadowColor=[UIColor grayColor].CGColor;</span><br><span class="line">layerShadow.shadowOffset=CGSizeMake(2, 1);</span><br><span class="line">layerShadow.shadowOpacity=1;</span><br><span class="line">layerShadow.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layerShadow.borderWidth=borderWidth;</span><br><span class="line">[self.view.layer addSublayer:layerShadow];</span><br><span class="line">//容器图层</span><br><span class="line">CALayer *layer=[[CALayer alloc]init];</span><br><span class="line">layer.bounds=bounds;</span><br><span class="line">layer.position=position;</span><br><span class="line">layer.backgroundColor=[UIColor redColor].CGColor;</span><br><span class="line">layer.cornerRadius=cornerRadius;</span><br><span class="line">layer.masksToBounds=YES;</span><br><span class="line">layer.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layer.borderWidth=borderWidth;</span><br><span class="line">//利用图层形变解决图像倒立问题</span><br><span class="line">layer.transform=CATransform3DMakeRotation(M_PI, 1, 0, 0);</span><br><span class="line">//设置图层代理</span><br><span class="line">layer.delegate=self;</span><br><span class="line">//添加图层到根图层</span><br><span class="line">[self.view.layer addSublayer:layer];</span><br><span class="line">//调用图层setNeedDisplay,否则代理方法不会被调用</span><br><span class="line">[layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark 绘制图形、图像到图层，注意参数中的ctx时图层的图形上下文，其中绘图位置也是相对图层而言的</span><br><span class="line">-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#123;</span><br><span class="line">//    NSLog(@&quot;%@&quot;,layer);//这个图层正是上面定义的图层</span><br><span class="line">UIImage *image=[UIImage imageNamed:@&quot;photo.jpg&quot;];</span><br><span class="line">//注意这个位置是相对于图层而言的不是屏幕</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT), image.CGImage);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>事实上如果仅仅就显示一张图片在图层中当然没有必要那么麻烦，直接设置图层contents就可以了，不牵涉到绘图也就没有倒立的问题了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  图层内容设置</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define PHOTO_HEIGHT 150</span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation KCMainViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">CGPoint position= CGPointMake(160, 200);</span><br><span class="line">CGRect bounds=CGRectMake(0, 0, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">CGFloat cornerRadius=PHOTO_HEIGHT/2;</span><br><span class="line">CGFloat borderWidth=2;</span><br><span class="line">//阴影图层</span><br><span class="line">CALayer *layerShadow=[[CALayer alloc]init];</span><br><span class="line">layerShadow.bounds=bounds;</span><br><span class="line">layerShadow.position=position;</span><br><span class="line">layerShadow.cornerRadius=cornerRadius;</span><br><span class="line">layerShadow.shadowColor=[UIColor grayColor].CGColor;</span><br><span class="line">layerShadow.shadowOffset=CGSizeMake(2, 1);</span><br><span class="line">layerShadow.shadowOpacity=1;</span><br><span class="line">layerShadow.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layerShadow.borderWidth=borderWidth;</span><br><span class="line">[self.view.layer addSublayer:layerShadow];</span><br><span class="line">//容器图层</span><br><span class="line">CALayer *layer=[[CALayer alloc]init];</span><br><span class="line">layer.bounds=bounds;</span><br><span class="line">layer.position=position;</span><br><span class="line">layer.backgroundColor=[UIColor redColor].CGColor;</span><br><span class="line">layer.cornerRadius=cornerRadius;</span><br><span class="line">layer.masksToBounds=YES;</span><br><span class="line">layer.borderColor=[UIColor whiteColor].CGColor;</span><br><span class="line">layer.borderWidth=borderWidth;</span><br><span class="line">//设置内容（注意这里一定要转换为CGImage）</span><br><span class="line">UIImage *image=[UIImage imageNamed:@&quot;photo.jpg&quot;];</span><br><span class="line">//    layer.contents=(id)image.CGImage;</span><br><span class="line">[layer setContents:(id)image.CGImage];</span><br><span class="line">//添加图层到根图层</span><br><span class="line">[self.view.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>既然如此为什么还大费周章的说形变呢，因为形变对于动画有特殊的意义。在动画开发中形变往往不是直接设置transform，而是通过keyPath进行设置。这种方法设置形变的本质和前面没有区别，只是利用了KVC可以动态修改其属性值而已，但是这种方式在动画中确实很常用的，因为它可以很方便的将几种形变组合到一起使用。同样是解决动画旋转问题，只要将前面的旋转代码改为下面的代码即可：</p>
<blockquote>
<p>[layer setValue:@M_PI forKeyPath:@”transform.rotation.x”];</p>
</blockquote>
<p>当然，通过key path设置形变参数就需要了解有哪些key path可以设置，这里就不再一一列举，大家可以参照Xcode帮助文档中“CATransform3D Key Paths”一节，里面描述的很详细。</p>
<p>###使用自定义图层绘图</p>
<p>在自定义图层中绘图时只要自己编写一个类继承于CALayer然后在drawInContext:中绘图即可。同前面在代理方法绘图一样，要显示图层中绘制的内容也要调用图层的setNeedDisplay方法，否则drawInContext方法将不会调用。</p>
<p>在使用Quartz 2D在UIView中绘制图形的本质也是绘制到图层中，为了说明这个问题下面演示自定义图层绘图时没有直接在视图控制器中调用自定义图层，而是在一个UIView将自定义图层添加到UIView的根图层中（例子中的UIView跟自定义图层绘图没有直接关系）。从下面的代码中可以看到：UIView在显示时其根图层会自动创建一个CGContextRef（CALayer本质使用的是位图上下文），同时调用图层代理（UIView创建图层会自动设置图层代理为其自身）的<strong>draw: inContext:</strong>方法并将图形上下文作为参数传递给这个方法。而在UIView的<strong>draw:inContext:</strong>方法中会调用其drawRect:方法，在<strong>drawRect:</strong>方法中使用<strong>UIGraphicsGetCurrentContext()</strong>方法得到的上下文正是前面创建的上下文。<br>KCLayer.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  KCLayer.m</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCLayer.h&quot;</span><br><span class="line">@implementation KCLayer</span><br><span class="line">-(void)drawInContext:(CGContextRef)ctx&#123;</span><br><span class="line">NSLog(@&quot;3-drawInContext:&quot;);</span><br><span class="line">NSLog(@&quot;CGContext:%@&quot;,ctx);</span><br><span class="line">//    CGContextRotateCTM(ctx, M_PI_4);</span><br><span class="line">CGContextSetRGBFillColor(ctx, 135.0/255.0, 232.0/255.0, 84.0/255.0, 1);</span><br><span class="line">CGContextSetRGBStrokeColor(ctx, 135.0/255.0, 232.0/255.0, 84.0/255.0, 1);</span><br><span class="line">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span><br><span class="line">//    CGContextFillEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));</span><br><span class="line">CGContextMoveToPoint(ctx, 94.5, 33.5);</span><br><span class="line">//// Star Drawing</span><br><span class="line">CGContextAddLineToPoint(ctx,104.02, 47.39);</span><br><span class="line">CGContextAddLineToPoint(ctx,120.18, 52.16);</span><br><span class="line">CGContextAddLineToPoint(ctx,109.91, 65.51);</span><br><span class="line">CGContextAddLineToPoint(ctx,110.37, 82.34);</span><br><span class="line">CGContextAddLineToPoint(ctx,94.5, 76.7);</span><br><span class="line">CGContextAddLineToPoint(ctx,78.63, 82.34);</span><br><span class="line">CGContextAddLineToPoint(ctx,79.09, 65.51);</span><br><span class="line">CGContextAddLineToPoint(ctx,68.82, 52.16);</span><br><span class="line">CGContextAddLineToPoint(ctx,84.98, 47.39);</span><br><span class="line">CGContextClosePath(ctx);</span><br><span class="line">CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>KCView.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  KCView.m</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCView.h&quot;</span><br><span class="line">#import &quot;KCLayer.h&quot;</span><br><span class="line">@implementation KCView</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">NSLog(@&quot;initWithFrame:&quot;);</span><br><span class="line">if (self=[super initWithFrame:frame]) &#123;</span><br><span class="line">KCLayer *layer=[[KCLayer alloc]init];</span><br><span class="line">layer.bounds=CGRectMake(0, 0, 185, 185);</span><br><span class="line">layer.position=CGPointMake(160,284);</span><br><span class="line">layer.backgroundColor=[UIColor colorWithRed:0 green:146/255.0 blue:1.0 alpha:1.0].CGColor;</span><br><span class="line">//显示图层</span><br><span class="line">[layer setNeedsDisplay];</span><br><span class="line">[self.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">-(void)drawRect:(CGRect)rect&#123;</span><br><span class="line">NSLog(@&quot;2-drawRect:&quot;);</span><br><span class="line">NSLog(@&quot;CGContext:%@&quot;,UIGraphicsGetCurrentContext());//得到的当前图形上下文正是drawLayer中传递的</span><br><span class="line">[super drawRect:rect];</span><br><span class="line">&#125;</span><br><span class="line">-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#123;</span><br><span class="line">NSLog(@&quot;1-drawLayer:inContext:&quot;);</span><br><span class="line">NSLog(@&quot;CGContext:%@&quot;,ctx);</span><br><span class="line">[super drawLayer:layer inContext:ctx];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>KCMainViewController.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  KCMainViewController.m</span><br><span class="line">//  CALayer</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#import &quot;KCView.h&quot;</span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">KCView *view=[[KCView alloc]initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">view.backgroundColor=[UIColor colorWithRed:249.0/255.0 green:249.0/255.0 blue:249.0/255.0 alpha:1];</span><br><span class="line">[self.view addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-37d68836198e596b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS开发系列-让你的应用“动”起来--CALayer/" data-id="cjgdiqq76000hkezihrt9cwiw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-文字样式处理总结（字体、前背景色、斜体、加粗、对齐、行间距、段间距、动态获取字符串label宽高等）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-文字样式处理总结（字体、前背景色、斜体、加粗、对齐、行间距、段间距、动态获取字符串label宽高等）/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-文字样式处理总结（字体、前背景色、斜体、加粗、对齐、行间距、段间距、动态获取字符串label宽高等）/">iOS-文字样式处理总结（字体、前背景色、斜体、加粗、对齐、行间距、段间距、动态获取字符串label宽高等）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在iOS开发中，常常会有一段文字显示不同的颜色和字体，或者给某几个文字加删除线或下划线的需求。NSMuttableAttstring（带属性的字符串），可以灵活实现以上功能。 NSMutableParagraphStyle段落风格，设置行间距、段间距、缩进、对齐方式等。</p>
<ol>
<li>实例化方法和使用方法<br>实例化方法：<br>使用字符串初始化</li>
</ol>
<ul>
<li>(id)initWithString:(NSString <em>)str;//例：NSMutableAttributedString </em>AttributedStr = [[NSMutableAttributedStringalloc]initWithString:@”文字样式处理”];</li>
</ul>
<p>字典中存放一些属性名和属性值：</p>
<ul>
<li>(id)initWithString:(NSString <em>)str attributes:(NSDictionary </em>)attrs;//如:NSDictionary <em>attributeDict = [NSDictionarydictionaryWithObjectsAndKeys: [UIFontsystemFontOfSize:15.0],NSFontAttributeName, [UIColorredColor],NSForegroundColorAttributeName, NSUnderlineStyleAttributeName,NSUnderlineStyleSingle,nil];NSMutableAttributedString </em>AttributedStr = [[NSMutableAttributedStringalloc]initWithString:@”文字样式处理” attributes:attributeDict];</li>
</ul>
<p>使用NSAttributedString初始化，跟NSMutableString，NSString类似:</p>
<ul>
<li>(id)initWithAttributedString:(NSAttributedString *)attester;</li>
</ul>
<p>使用方法：<br>为某一范围内文字设置多个属性</p>
<ul>
<li>(void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;</li>
</ul>
<p>为某一范围内文字添加某个属性</p>
<ul>
<li>(void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range;</li>
</ul>
<p>为某一范围内文字添加多个属性</p>
<ul>
<li>(void)addAttributes:(NSDictionary *)attrs range:(NSRange)range;</li>
</ul>
<p>移除某范围内的某个属性</p>
<ul>
<li>(void)removeAttribute:(NSString *)name range:(NSRange)range;</li>
</ul>
<ol start="2">
<li>常见的属性及说明</li>
</ol>
<p><strong>NSFontAttributeName</strong> //字体<br><strong>NSParagraphStyleAttributeName</strong> //段落格式<br><strong>NSForegroundColorAttributeName</strong> //字体颜色<br><strong>NSBackgroundColorAttributeName</strong> //背景颜色<br><strong>NSStrikethroughStyleAttributeName</strong> //删除线格式<br><strong>NSUnderlineStyleAttributeName</strong> //下划线格式<br><strong>NSStrokeColorAttributeName</strong> //删除线颜色<br><strong>NSStrokeWidthAttributeName</strong>//删除线宽度<br><strong>NSShadowAttributeName</strong> //阴影<br><strong>NSParagraphStyleAttributeName</strong>//段落的风格（设置首行，行间距，对齐方式什么的）</p>
<p>NSMutableParagraphStyle <em>paragraphStyle = [[NSMutableParagraphStyle alloc] init];<br>paragraphStyle.lineSpacing = 10;// 字体的行间距 paragraphStyle.firstLineHeadIndent = 20.0f;//首行缩进 paragraphStyle.alignment = NSTextAlignmentJustified;//（两端对齐的）文本对齐方式：（左，中，右，两端对齐，自然）<br>paragraphStyle.lineBreakMode = NSLineBreakByTruncatingTail;//结尾部分的内容以……方式省略 ( “…wxyz” ,”abcd…” ,”ab…yz”)<br>paragraphStyle.headIndent = 20;//整体缩进(首行除外)<br>paragraphStyle.tailIndent = 20;//<br>paragraphStyle.minimumLineHeight = 10;//最低行高<br>paragraphStyle.maximumLineHeight = 20;//最大行高<br>paragraphStyle.paragraphSpacing = 15;//段与段之间的间距<br>paragraphStyle.paragraphSpacingBefore = 22.0f;//段首行空白空间/</em> Distance between the bottom of the previous paragraph (or the end of its paragraphSpacing, if any) and the top of this paragraph. <em>/<br>paragraphStyle.baseWritingDirection = NSWritingDirectionLeftToRight;//从左到右的书写方向（一共三种）<br>paragraphStyle.lineHeightMultiple = 15;//</em> Natural line height is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. *//<br>paragraphStyle.hyphenationFactor = 1;//连字属性 在iOS，唯一支持的值分别为0和1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">两个样式枚举</span><br><span class="line">typedef NS_ENUM(NSInteger, NSLineBreakMode) &#123;/* What to do with long lines */ </span><br><span class="line">NSLineBreakByWordWrapping = 0, /* Wrap at word boundaries, default */</span><br><span class="line"> NSLineBreakByCharWrapping,/* Wrap at character boundaries */ </span><br><span class="line">NSLineBreakByClipping,/* Simply clip */剪掉后面显示不了的部分 </span><br><span class="line">NSLineBreakByTruncatingHead,/* Truncate at head of line: &quot;...wxyz&quot; */头部分的内容以……方式省略 </span><br><span class="line">NSLineBreakByTruncatingTail,/* Truncate at tail of line: &quot;abcd...&quot; */结尾部分的内容以……方式省略 </span><br><span class="line">NSLineBreakByTruncatingMiddle/* Truncate middle of line: &quot;ab...yz&quot; */中间部分的内容以……方式省略 </span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(6_0); </span><br><span class="line">typedef NS_ENUM(NSInteger, NSWritingDirection) &#123; </span><br><span class="line">NSWritingDirectionNatural = -1, // Determines direction using the Unicode Bidi Algorithm rules P2 and P3  </span><br><span class="line">NSWritingDirectionLeftToRight = 0, // Left to right writing direction 左到右的书写方向  </span><br><span class="line">NSWritingDirectionRightToLeft = 1 // Right to left writing direction 右到左的书写方向 </span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(6_0);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* NSFontAttributeName 字体大小 </span><br><span class="line">NSParagraphStyleAttributeName 段落的风格（设置首行，行间距，对齐方式什么的） </span><br><span class="line">NSKernAttributeName 字间距 */</span><br><span class="line"> NSDictionary *attributes = @&#123; </span><br><span class="line">NSFontAttributeName:[UIFont systemFontOfSize:15], </span><br><span class="line">NSParagraphStyleAttributeName:paragraphStyle, </span><br><span class="line">NSKernAttributeName:@(10), </span><br><span class="line">&#125;; </span><br><span class="line">textView.attributedText = [[NSAttributedString alloc] initWithString:textView.text attributes:attributes];</span><br></pre></td></tr></table></figure>
<p>再来个实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//随便定义一个字符串，做测试使用 </span><br><span class="line">NSString *massageStr = @&quot;\t北京乌托邦有限公司（以下简称“乌托邦”）在此特别提醒您（用户）在注册成为用户之前，请认真阅读本《用户协议》（以下简称“协议”），确保您充分理解本协议中各条款。请您审慎阅读并选择接受或不接受本协议。除非您接受本协议所有条款，否则您无权注册、登录或使用本协议所涉服务。您的注册、登录、使用等行为将视为对本协议的接受，并同意接受本协议各项条款的约束。\r\n \t本协议约定乌托邦与用户之间关于“乌托邦”软件服务（以下简称“服务”）的权利义务。“用户”是指注册、登录、使用本服务的个人。本协议可由乌托邦随时更新，更新后的协议条款一旦公布即代替原来的协议条款，恕不再另行通知，用户可在本网站查阅最新版协议条款。在乌托邦修改协议条款后，如果用户不接受修改后的条款，请立即停止使用乌托邦提供的服务，用户继续使用乌托邦提供的服务将被视为接受修改后的协议。&quot;; </span><br><span class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:massageStr]; </span><br><span class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</span><br><span class="line">[paragraphStyle setLineSpacing:20];</span><br><span class="line">//调整行间距</span><br><span class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [self.agreementText length])];</span><br><span class="line">[attributedString addAttribute:NSForegroundColorAttributeName value:</span><br><span class="line">[UIColor redColor] range:NSMakeRange(0, 12)]; // 0为起始位置 length是从起始位置开始 设置指定颜色的长度 </span><br><span class="line">[attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(18, 3)]; //设置尺寸 </span><br><span class="line">[attributedString addAttribute:NSFontAttributeName value:[UIFont boldSystemFontOfSize:20] range:NSMakeRange(18, 3)]; // 0为起始位置 length是从起始位置开始 设置指定字体尺寸的长度</span><br></pre></td></tr></table></figure></p>
<p>根据字符串获取宽高<br>根据宽度求高度 content 计算的内容 width 计算的宽度 font字体大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (CGFloat)getHeightWithContent:(NSString *)content width:(CGFloat)width font:(CGFloat)font&#123; </span><br><span class="line">CGRect rect = [content boundingRectWithSize:CGSizeMake(width, 999) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;</span><br><span class="line">NSFontAttributeName:[UIFont systemFontOfSize:font]&#125;  context:nil]; </span><br><span class="line">return rect.size.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据高度度求宽度 content 计算的内容 Height 计算的高度 font字体大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (CGFloat)getWidthWithContent:(NSString *)content height:(CGFloat)height font:(CGFloat)font&#123; </span><br><span class="line">CGRect rect = [content boundingRectWithSize:CGSizeMake(999, height) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;</span><br><span class="line">NSFontAttributeName:[UIFont systemFontOfSize:font]&#125; context:nil]; </span><br><span class="line">return rect.size.width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，设置删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NSStrikethroughColorAttributeName 的时候，值也是这个枚举。</span><br><span class="line"></span><br><span class="line">// NSUnderlineStyleNone 不设置下划线／删除线</span><br><span class="line"></span><br><span class="line">// NSUnderlineStyleSingle 设置下划线／删除线为细的单线</span><br><span class="line"></span><br><span class="line">// NSUnderlineStyleThick 设置下划线／删除线为粗的单线</span><br><span class="line"></span><br><span class="line">// NSUnderlineStyleDouble 设置下划线／删除线为细的双线</span><br><span class="line"></span><br><span class="line">// NSUnderlinePatternSolid 设置下划线／删除线样式为连续的实线</span><br><span class="line"></span><br><span class="line">// NSUnderlinePatternDot 设置下划线／删除线样式为点，也就是虚线，比如这样：－－－－－－</span><br><span class="line"></span><br><span class="line">// NSUnderlinePatterDash 设置下划线／删除线样式为破折号，比如这样：—— —— ——</span><br><span class="line"></span><br><span class="line">// NSUnderlinePatternDashDot 设置下划线／删除线样式为连续的破折号和点，比如这样：——－——－——－</span><br><span class="line"></span><br><span class="line">// NSUnderlinePatternDashDotDot 设置下划线／删除线样式为连续的破折号、点、点，比如：——－－——－－——－－</span><br><span class="line"></span><br><span class="line">// NSUnderlineByWord 在有空格的地方不设置下划线／删除线</span><br><span class="line">在设置以上属性时，可以以|分隔，同时设置多个属性</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-文字样式处理总结（字体、前背景色、斜体、加粗、对齐、行间距、段间距、动态获取字符串label宽高等）/" data-id="cjgdiqq6y0009kezik6ws71jg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/24/iOS-开发中手势方法的使用/">iOS-开发中手势方法的使用</a>
          </li>
        
          <li>
            <a href="/2018/04/24/C指针--函数形参int-p与int--p的区别/">C指针--函数形参int-p与int--p的区别</a>
          </li>
        
          <li>
            <a href="/2018/04/24/KVO键值依赖/">KVO键值依赖</a>
          </li>
        
          <li>
            <a href="/2018/04/24/iOS开发过程中遇到的新奇玩意儿/">iOS开发过程中遇到的新奇玩意儿</a>
          </li>
        
          <li>
            <a href="/2018/04/24/iOS开发证书要点详解，ios证书详解/">iOS开发证书要点详解，ios证书详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Kasign<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>