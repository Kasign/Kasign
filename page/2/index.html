<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-C指针详解(经典,非常详细)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/C指针详解(经典,非常详细)/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/C指针详解(经典,非常详细)/">C指针详解(经典,非常详细)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言-复杂类型说明"><a href="#前言-复杂类型说明" class="headerlink" title="前言:复杂类型说明"></a>前言:复杂类型说明</h2><p>要了解指针,多多少少会出现一些比较复杂的类型,所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单,一个类型里会出现很多运算符,他们也像普通的表达式一样,有优先级,其优先级和运算优先级一样,所以我总结了一下其原则:从变量名处起,根据运算符优先级结合,一步一步分析.下面让我们先从简单的类型开始慢慢分析吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  int p; //这是一个普通的整型变量</span><br><span class="line">2.  int *p;  //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span><br><span class="line">3.  int p[3];  //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span><br><span class="line">4.  int *p[3];   //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组</span><br><span class="line">5.  int b(*p)[3];  //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针</span><br><span class="line">6.  int **p;  //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span><br><span class="line">7.  int p(int);  //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span><br><span class="line">8.  Int (*p)(int );  //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针</span><br><span class="line">9.  int *(*p(int ))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span><br></pre></td></tr></table></figure></p>
<p>说到这里也就差不多了,我们的任务也就这么多,理解了这几个类型,其它的类型对我们来说也是小菜了,不过我们一般不会用太复杂的类型,那样会大大减小程序的可读性,请慎用,这上面的几种类型已经足够我们用了.</p>
<p>###一、细说指针<br>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。让我们分别说明。</p>
<p>先声明几个指针放着做例子：<br>例一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)int*ptr;  </span><br><span class="line">(2)char*ptr;  </span><br><span class="line">(3)int**ptr;  </span><br><span class="line">(4)int(*ptr)[3];  </span><br><span class="line">(5)int*(*ptr)[4];</span><br></pre></td></tr></table></figure></p>
<h4 id="1-指针的类型"><a href="#1-指针的类型" class="headerlink" title="1.指针的类型"></a>1.指针的类型</h4><p>从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)int*ptr;//指针的类型是int*</span><br><span class="line"></span><br><span class="line">(2)char*ptr;//指针的类型是char*</span><br><span class="line"></span><br><span class="line">(3)int**ptr;//指针的类型是int**</span><br><span class="line"></span><br><span class="line">(4)int(*ptr)[3];//指针的类型是int(*)[3]</span><br><span class="line"></span><br><span class="line">(5)int*(*ptr)[4];//指针的类型是int*(*)[4]</span><br></pre></td></tr></table></figure></p>
<p>怎么样？找出指针的类型的方法是不是很简单？</p>
<p>####2.指针所指向的类型</p>
<p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>
<p>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)int *ptr; //指针所指向的类型是int</span><br><span class="line"></span><br><span class="line">(2)char *ptr; //指针所指向的的类型是char</span><br><span class="line"></span><br><span class="line">(3)int **ptr; //指针所指向的的类型是int*</span><br><span class="line"></span><br><span class="line">(4)int (*ptr)[3]; //指针所指向的的类型是int()[3]</span><br><span class="line"></span><br><span class="line">(5)int *(*ptr)[4]; //指针所指向的的类型是int*()[4]</span><br></pre></td></tr></table></figure></p>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p>
<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。</p>
<p>####3.指针的值—-或者叫指针所指向的内存区或地址</p>
<p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p>
<p> <strong>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）</strong> </p>
<p>####4 指针本身所占据的内存区</p>
<p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。</p>
<h2 id="二、指针的算术运算"><a href="#二、指针的算术运算" class="headerlink" title="二、指针的算术运算"></a>二、指针的算术运算</h2><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：</p>
<p>例二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  char a[20];</span><br><span class="line">2.  int *ptr=(int*)a; //强制类型转换并不会改变a 的类型</span><br><span class="line">3.  ptr++;</span><br></pre></td></tr></table></figure></p>
<p>在上例中，指针ptr 的类型是int*,它指向的类型是int，它被初始化为指向整型变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因为在32 位程序中，int 占4 个字节。由于地址是用字节做单位的，故ptr 所指向的地址由原来的变量a 的地址向高地址方向增加了4 个字节。由于char 类型的长度是一个字节，所以，原来ptr 是指向数组a 的第0 号单元开始的四个字节，此时指向了数组a 中从第4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：</p>
<p>例三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int array[20]=&#123;0&#125;;  </span><br><span class="line">int *ptr=array;  </span><br><span class="line">for(i=0;i&lt;20;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">    (*ptr)++;  </span><br><span class="line">    ptr++；  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。</p>
<p>再看例子：</p>
<p>例四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[20]=&quot;You_are_a_girl&quot;;  </span><br><span class="line">int *ptr=(int *)a;  </span><br><span class="line">ptr+=5;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，ptr 被加上了5，编译器是这样处理的：将指针ptr 的值加上5 乘sizeof(int)，在32 位程序中就是加上了5 乘4=20。由于地址的单位是字节，故现在的ptr 所指向的地址比起加5 后的ptr 所指向的地址来说，向高地址方向移动了20 个字节。<br>在这个例子中，没加5 前的ptr 指向数组a 的第0 号单元开始的四个字节，加5 后，ptr 已经指向了数组a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去5，那么处理过程大同小异，只不过ptr 的值是被减去5 乘sizeof(int)，新的ptr 指向的地址将比原来的ptr 所指向的地址向低地址方向移动了20 个字节。<br>下面请允许我再举一个例子:(一个误区)</p>
<p>例五:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    char a[20]=&quot; You_are_a_girl&quot;;  </span><br><span class="line">    char *p=a;  </span><br><span class="line">    char **ptr=&amp;p;  </span><br><span class="line">    //printf(&quot;p=%d\n&quot;,p);  </span><br><span class="line">    //printf(&quot;ptr=%d\n&quot;,ptr);  </span><br><span class="line">    //printf(&quot;*ptr=%d\n&quot;,*ptr);  </span><br><span class="line">    printf(&quot;**ptr=%c\n&quot;,**ptr);  </span><br><span class="line">    ptr++;  </span><br><span class="line">    //printf(&quot;ptr=%d\n&quot;,ptr);  </span><br><span class="line">    //printf(&quot;*ptr=%d\n&quot;,*ptr);  </span><br><span class="line">    printf(&quot;**ptr=%c\n&quot;,**ptr);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>误区一、</strong></p>
<p>输出答案为Y 和o</p>
<p>误解:ptr 是一个char 的二级指针,当执行ptr++;时,会使指针加一个sizeof(char),所以输出如上结果,这个可能只是少部分人的结果.</p>
<p><strong>误区二、</strong></p>
<p>输出答案为Y 和a误解:ptr 指向的是一个char <em>类型,当执行ptr++;时,会使指针加一个sizeof(char </em>)(有可能会有人认为这个值为1,那就会得到误区一的答案,这个值应该是4,参考前面内容), 即&amp;p+4; 那进行一次取值运算不就指向数组中的第五个元素了吗?那输出的结果不就是数组中第五个元素了吗?答案是否定的.</p>
<p><strong>正解:</strong> </p>
<p>ptr 的类型是char *<em>,指向的类型是一个char </em>类型,该指向的地址就是p的地址(&amp;p),当执行ptr++;时,会使指针加一个sizeof(char<em>),即&amp;p+4;那</em>(&amp;p+4)指向哪呢,这个你去问上帝吧,或者他会告诉你在哪?所以最后的输出会是一个随机的值,或许是一个非法操作.</p>
<p><strong>总结一下:</strong></p>
<p>一个指针ptrold 加(减)一个整数n 后，结果是一个新的指针ptrnew，ptrnew 的类型和ptrold 的类型相同，ptrnew 所指向的类型和ptrold所指向的类型也相同。ptrnew 的值将比ptrold 的值增加(减少)了n 乘sizeof(ptrold 所指向的类型)个字节。就是说，ptrnew 所指向的内存区将比ptrold 所指向的内存区向高(低)地址方向移动了n 乘sizeof(ptrold 所指向的类型)个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。</p>
<p>###三、运算符&amp;和*</p>
<p>这里&amp;是取地址运算符，*是间接运算符。</p>
<p>&amp;a 的运算结果是一个指针，指针的类型是a 的类型加个*，指针所指向的类型是a 的类型，指针所指向的地址嘛，那就是a 的地址。</p>
<p><em>p 的运算结果就五花八门了。总之 </em>p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址。</p>
<p>例六：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a=12; int b; int *p; int **ptr;  </span><br><span class="line">p=&amp;a; //&amp;a 的结果是一个指针，类型是int*，指向的类型是  </span><br><span class="line">//int，指向的地址是a 的地址。  </span><br><span class="line">*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是  </span><br><span class="line">//p 所指向的地址，显然，*p 就是变量a。  </span><br><span class="line">ptr=&amp;p; //&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，  </span><br><span class="line">//在这里是int **。该指针所指向的类型是p 的类型，这  </span><br><span class="line">//里是int*。该指针所指向的地址就是指针p 自己的地址。  </span><br><span class="line">*ptr=&amp;b; //*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针  </span><br><span class="line">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋  </span><br><span class="line">//值就是毫无问题的了。  </span><br><span class="line">**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，  </span><br><span class="line">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span><br></pre></td></tr></table></figure></p>
<h2 id="四、指针表达式"><a href="#四、指针表达式" class="headerlink" title="四、指针表达式"></a>四、指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。</p>
<p>下面是一些指针表达式的例子：</p>
<p>例七：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a,b;  </span><br><span class="line">int array[10];  </span><br><span class="line">int *pa;  </span><br><span class="line">pa=&amp;a; //&amp;a 是一个指针表达式。  </span><br><span class="line">Int **ptr=&amp;pa; //&amp;pa 也是一个指针表达式。  </span><br><span class="line">*ptr=&amp;b; //*ptr 和&amp;b 都是指针表达式。  </span><br><span class="line">pa=array;  </span><br><span class="line">pa++; //这也是指针表达式。</span><br></pre></td></tr></table></figure></p>
<p>例八：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char *arr[20];  </span><br><span class="line">char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式  </span><br><span class="line">char *str;  </span><br><span class="line">str=*parr; //*parr 是指针表达式  </span><br><span class="line">str=*(parr+1); //*(parr+1)是指针表达式  </span><br><span class="line">str=*(parr+2); //*(parr+2)是指针表达式</span><br></pre></td></tr></table></figure></p>
<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p>
<p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&amp;a 不是一个左值，因为它还没有占据明确的内存。<em>ptr 是一个左值，因为</em>ptr 这个指针已经占据了内存，其实<em>ptr 就是指针pa，既然pa 已经在内存中有了自己的位置，那么</em>ptr 当然也有了自己的位置。</p>
<p>###五、数组和指针的关系</p>
<p>数组的数组名其实可以看作一个指针。看下例：</p>
<p>例九：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int array[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;,value;  </span><br><span class="line">value=array[0]; //也可写成：value=*array;  </span><br><span class="line">value=array[3]; //也可写成：value=*(array+3);  </span><br><span class="line">value=array[4]; //也可写成：value=*(array+4);</span><br></pre></td></tr></table></figure>
<p>上例中，一般而言数组名array 代表数组本身，类型是int[10]，但如果把array 看做指针的话，它指向数组的第0 个单元，类型是int<em> 所指向的类型是数组单元的类型即int。因此</em>array 等于0 就一点也不奇怪了。同理，array+3 是一个指向数组第3 个单元的指针，所以*(array+3)等于3。其它依此类推。</p>
<p>例十：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char *str[3]=&#123;  </span><br><span class="line">    &quot;Hello,thisisasample!&quot;,  </span><br><span class="line">    &quot;Hi,goodmorning.&quot;,  </span><br><span class="line">    &quot;Helloworld&quot;  </span><br><span class="line">&#125;;  </span><br><span class="line">char s[80]；  </span><br><span class="line">strcpy(s,str[0]); //也可写成strcpy(s,*str);  </span><br><span class="line">strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));  </span><br><span class="line">strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));</span><br></pre></td></tr></table></figure></p>
<p>上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str 当作一个指针的话，它指向数组的第0 号单元，它的类型是char *<em>，它指向的类型是char </em>。</p>
<p><em>str 也是一个指针，它的类型是char </em>，它所指向的类型是char，它指向的地址是字符串”Hello,thisisasample!”的第一个字符的地址，即’H’的地址。注意:字符串相当于是一个数组,在内存中以数组的形式储存,只不过字符串是一个数组常量,内容不可改变,且只能是右值.如果看成指针的话,他即是常量指针,也是指针常量.</p>
<p>str+1 也是一个指针，它指向数组的第1 号单元，它的类型是char*<em>，它指向的类型是char</em>。</p>
<p><em>(str+1)也是一个指针，它的类型是char</em>，它所指向的类型是char，它指向”Hi,goodmorning.”的第一个字符’H’</p>
<p><strong>下面总结一下数组的数组名(数组中储存的也是数组)的问题:</strong></p>
<p>声明了一个数组TYPE array[n]，则数组名称array 就有了两重含义：</p>
<p>第一，它代表整个数组，它的类型是TYPE[n]；</p>
<p>第二，它是一个常量指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0 号单元，该指针自己占有单独的内存区，注意它和数组第0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。在不同的表达式中数组名array 可以扮演不同的角色。在表达式sizeof(array)中，数组名array 代表数组本身，故这时sizeof 函数测出的是整个数组的大小。</p>
<p>在表达式<em>array 中，array 扮演的是指针，因此这个表达式的结果就是数组第0 号单元的值。sizeof(</em>array)测出的是数组单元的大小。</p>
<p>表达式array+n（其中n=0，1，2，…..）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是TYPE *，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。在32 位程序中结果是4</p>
<p>例十一:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int array[10];  </span><br><span class="line">int (*ptr)[10];  </span><br><span class="line">ptr=&amp;array;：</span><br></pre></td></tr></table></figure>
<p>上例中ptr 是一个指针，它的类型是int(*)[10]，他指向的类型是int[10] ，我们用整个数组的首地址来初始化它。在语句ptr=&amp;array中，array 代表数组本身。</p>
<p>本节中提到了函数sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？</p>
<p>答案是前者。例如：</p>
<p>int(*ptr)[10];</p>
<p>则在32 位程序中，有：</p>
<p>sizeof(int(*)[10])==4</p>
<p>sizeof(int[10])==40</p>
<p>sizeof(ptr)==4</p>
<p>实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<p>###六、指针和结构类型的关系</p>
<p>可以声明一个指向结构类型对象的指针。</p>
<p>例十二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct  </span><br><span class="line">&#123;  </span><br><span class="line">    int a;  </span><br><span class="line">    int b;  </span><br><span class="line">    int c;  </span><br><span class="line">&#125;;  </span><br><span class="line">struct MyStruct ss=&#123;20,30,40&#125;;  </span><br><span class="line">//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。  </span><br><span class="line">struct MyStruct *ptr=&amp;ss;  </span><br><span class="line">//声明了一个指向结构对象ss 的指针。它的类型是  </span><br><span class="line">//MyStruct *,它指向的类型是MyStruct。  </span><br><span class="line">int *pstr=(int*)&amp;ss;  </span><br><span class="line">//声明了一个指向结构对象ss 的指针。但是pstr 和  </span><br><span class="line">//它被指向的类型ptr 是不同的。</span><br></pre></td></tr></table></figure></p>
<p><strong>请问怎样通过指针ptr 来访问ss 的三个成员变量？<br>答案：</strong></p>
<p>ptr-&gt;a; //指向运算符，或者可以这们(*ptr).a,建议使用前者</p>
<p>ptr-&gt;b;</p>
<p>ptr-&gt;c;</p>
<p><strong>又请问怎样通过指针pstr 来访问ss 的三个成员变量？<br>答案：</strong></p>
<p>*pstr； //访问了ss 的成员a。</p>
<p>*(pstr+1); //访问了ss 的成员b。</p>
<p>*(pstr+2) //访问了ss 的成员c。</p>
<p>虽然我在我的MSVC++6.0 上调式过上述代码，但是要知道，这样使用pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)</p>
<p>例十三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int array[3]=&#123;35,56,37&#125;;  </span><br><span class="line">int *pa=array;  </span><br><span class="line">//通过指针pa 访问数组array 的三个单元的方法是：  </span><br><span class="line">*pa; //访问了第0 号单元  </span><br><span class="line">*(pa+1); //访问了第1 号单元  </span><br><span class="line">*(pa+2); //访问了第2 号单元</span><br></pre></td></tr></table></figure></p>
<p>从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。</p>
<p>所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个”填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。</p>
<p>所以，在例十二中，即使<em>pstr 访问到了结构对象ss 的第一个成员变量a，也不能保证</em>(pstr+1)就一定能访问到结构成员b。因为成员a 和成员b 之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。</p>
<p>不过指针访问结构成员的正确方法应该是象例十二中使用指针ptr 的方法。</p>
<p>###七、指针和函数的关系</p>
<p>可以把一个指针声明成为一个指向函数的指针。</p>
<p>int fun1(char *,int);</p>
<p>int (<em>pfun1)(char </em>,int);</p>
<p>pfun1=fun1;</p>
<p>int a=(*pfun1)(“abcdefg”,7); //通过函数指针调用函数。</p>
<p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<p>例十四：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int fun(char *);  </span><br><span class="line">inta;  </span><br><span class="line">char str[]=&quot;abcdefghijklmn&quot;;  </span><br><span class="line">a=fun(str);  </span><br><span class="line">int fun(char *s)  </span><br><span class="line">&#123;  </span><br><span class="line">    int num=0;  </span><br><span class="line">    for(int i=0;;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        num+=*s;s++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中的函数fun 统计一个字符串中各个字符的ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把str作为实参传递给形参s 后，实际是把str 的值传递给了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自占用各自的存储空间。在函数体内对s 进行自加1 运算，并不意味着同时对str 进行了自加1 运算。</p>
<p>###八、指针类型转换</p>
<p>当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。</p>
<p>例十五：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f=12.3;  </span><br><span class="line">float *fptr=&amp;f;  </span><br><span class="line">int *p;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，假如我们想让指针p 指向实数f，应该怎么办？</p>
<p>是用下面的语句吗？</p>
<p>p=&f;</p>
<p>不对。因为指针p 的类型是int <em>，它指向的类型是int。表达式&amp;f 的结果是一个指针，指针的类型是float </em>,它指向的类型是float。</p>
<p>两者不一致，直接赋值的方法是不行的。至少在我的MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行”强制类型转换”：</p>
<p>p=(int*)&f;</p>
<p>如果有一个指针p，我们需要把它的类型和所指向的类型改为TYEP <em>TYPE， 那么语法格式是： (TYPE </em>)p；</p>
<p>这样强制类型转换的结果是一个新指针，该新指针的类型是TYPE *，它指向的类型是TYPE，它指向的地址就是原指针指向的地址。</p>
<p>而原来的指针p 的一切属性都没有被修改。（切记）</p>
<p>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换</p>
<p>例十六：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void fun(char*);  </span><br><span class="line">int a=125,b;  </span><br><span class="line">fun((char*)&amp;a);  </span><br><span class="line">void fun(char*s)  </span><br><span class="line">&#123;  </span><br><span class="line">    charc;  </span><br><span class="line">    c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;  </span><br><span class="line">    c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这是一个32 位程序，故int 类型占了四个字节，char 类型占一个字节。函数fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参&amp;a 的结果是一个指针，它的类型是int <em>，它指向的类型是int。形参这个指针的类型是char </em>，它指向的类型是char。这样，在实参和形参的结合过程中，我们必须进行一次从int <em>类型到char </em>类型的转换。</p>
<p><strong>结合这个例子，我们可以这样来</strong></p>
<p>想象编译器进行转换的过程：编译器先构造一个临时指针char <em>temp，然后执行temp=(char </em>)&amp;a，最后再把temp 的值传递给s。所以最后的结果是：s 的类型是char *,它指向的类型是char，它指向的地址就是a 的首地址。</p>
<p>我们已经知道，指针的值就是指针指向的地址，在32 位程序中，指针的值其实是一个32 位整数。</p>
<p>那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a;  </span><br><span class="line">TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。  </span><br><span class="line">a=20345686;  </span><br><span class="line">ptr=20345686; //我们的目的是要使指针ptr 指向地址20345686  </span><br><span class="line">  </span><br><span class="line">ptr=a; //我们的目的是要使指针ptr 指向地址20345686  </span><br><span class="line">//编译一下吧。结果发现后面两条语句全是错的。那么我们的目的就不能达到了吗？不，还有办法：  </span><br><span class="line">unsigned int a;  </span><br><span class="line">TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。  </span><br><span class="line">a=N //N 必须代表一个合法的地址；  </span><br><span class="line">ptr=(TYPE*)a； //呵呵，这就可以了。</span><br></pre></td></tr></table></figure>
<p>严格说来这里的(TYPE <em>)和指针类型转换中的(TYPE </em>)还不一样。这里的(TYPE*)的意思是把无符号整数a 的值当作一个地址来看待。上面强调了a 的值必须代表一个合法的地址，否则的话，在你使用ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：</p>
<p>例十七：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=123,b;  </span><br><span class="line">int *ptr=&amp;a;  </span><br><span class="line">char *str;  </span><br><span class="line">b=(int)ptr; //把指针ptr 的值当作一个整数取出来。  </span><br><span class="line">str=(char*)b; //把这个整数的值当作一个地址赋给指针str。</span><br></pre></td></tr></table></figure></p>
<p>现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。</p>
<p>###九、指针的安全问题</p>
<p>看下面的例子：</p>
<p>例十八：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char s=&apos;a&apos;;  </span><br><span class="line">int *ptr;  </span><br><span class="line">ptr=(int *)&amp;s;  </span><br><span class="line">*ptr=1298；</span><br></pre></td></tr></table></figure></p>
<p>指针ptr 是一个int *类型的指针，它指向的类型是int。它指向的地址就是s 的首地址。在32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。</p>
<p>让我们再来看一例：</p>
<p>例十九：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a;  </span><br><span class="line">int *ptr=&amp;a;  </span><br><span class="line">ptr++;  </span><br><span class="line">*ptr=115;</span><br></pre></td></tr></table></figure></p>
<p>该例子完全可以通过编译，并能执行。但是看到没有？第3 句对指针ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。</p>
<p>而第4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。</p>
<p>在指针的强制类型转换：ptr1=(TYPE *)ptr2 中，如果sizeof(ptr2的类型)大于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。至于为什么，读者结合例十八来想一想，应该会明白的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/C指针详解(经典,非常详细)/" data-id="cjgdiqq6r0001keziwzksb5gk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-总结遇到的各种坑儿" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-总结遇到的各种坑儿/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-总结遇到的各种坑儿/">iOS-总结遇到的各种坑儿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>持续更新中。。。另一篇&lt;iOS开发过程中遇到的新奇玩意儿&gt;</p>
<p>##一、将字符串转换成json时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">NSError *err;</span><br><span class="line">id obj = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers</span><br><span class="line">                                                          error:&amp;err];</span><br></pre></td></tr></table></figure></p>
<p>如果jsonString是以下格式，即包含\r\n换行符时，会解析失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;content&quot;:&quot;测试\r\n &quot;,&quot;url&quot;:&quot;http://www.baidu.com&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>##二、跑项目的时候报错：dyld: Symbol not found: _OBJC_CLASS_$_<strong><br>如果</strong> 是自定义类的话，只需在Build Phases中的Compile Sources点击+添加那个类的.m。<br>如果 ** 是frameWork的话，只需在Build Phases中的Link Binary With Libraries将对应的frameWork右侧的Required改为Optional。</p>
<p>##三、float精度问题<br>在声明float的时候值就不准：<br>static float  a = 0.8；//0.8f也一样<br>打印a绝对不是0.8，要比0.8大一点</p>
<p>目前解决办法：<br> static const float a = 0.80;//这样完全是0.800000</p>
<p>手动去掉5.0、5.500这种后边的0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-(NSString*)converFloat:(CGFloat)floatValue&#123;</span><br><span class="line"></span><br><span class="line">    NSString * floatStr = [NSString stringWithFormat:@&quot;%f&quot;,floatValue];</span><br><span class="line">    </span><br><span class="line">    const char * floatChars = [floatStr UTF8String];</span><br><span class="line">    </span><br><span class="line">    int strLength = (int)floatStr.length;</span><br><span class="line">    </span><br><span class="line">    int zeroCount = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = strLength-1; i&gt;=0; i--) &#123;</span><br><span class="line">        if (floatChars[i] == &apos;0&apos; || floatChars[i] == &apos;.&apos;) &#123;</span><br><span class="line">            zeroCount++;</span><br><span class="line">            if (floatChars[i] == &apos;.&apos;) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    return [floatStr substringToIndex:strLength-zeroCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>oc提供的货币计算，会自动去掉5.0、5.500这种后边的0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(NSString*)calculateFloatA:(CGFloat)a floatB:(CGFloat)b&#123;</span><br><span class="line">    </span><br><span class="line">    NSString *strA = [NSString stringWithFormat:@&quot;%f&quot;,a];</span><br><span class="line">    NSString *strB = [NSString stringWithFormat:@&quot;%f&quot;,b];</span><br><span class="line">    </span><br><span class="line">    NSDecimalNumber *numberA = [NSDecimalNumber decimalNumberWithString:strA];</span><br><span class="line">    NSDecimalNumber *numberB = [NSDecimalNumber decimalNumberWithString:strB];</span><br><span class="line">    </span><br><span class="line">    /// 这里不仅包含Multiply还有加 减 除。</span><br><span class="line">    NSDecimalNumber *numResult = [numberA decimalNumberByMultiplyingBy:numberB];</span><br><span class="line">    </span><br><span class="line">    NSString *strResult = [numResult stringValue];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;NSDecimalNumber method  unrounding = %@&quot;,strResult);</span><br><span class="line">    </span><br><span class="line">    return strResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##四、时间NSDate 与NSString转换<br>NSString转换成NSDate会自动转换成UTC时区。</p>
<p>##五、tabbar图片变大问题<br> R:tabbar自动放大了图片，只要让图片保持原比例就行了<br> S:   UIImage <em> nomalImage =[UIImage imageNamed:[NSString stringWithFormat:@”%@”,imageName]];<br>    UIImage </em> selectImage =[UIImage imageNamed:[NSString stringWithFormat:@”%@_sele”,imageName]];<br>    selectImage = [selectImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];<br>    nomalImage = [nomalImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-总结遇到的各种坑儿/" data-id="cjgdiqq71000bkezi1rzw24j1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-画虚线的几种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-画虚线的几种方式/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-画虚线的几种方式/">iOS-画虚线的几种方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>重写drawRect方法</p>
<ul>
<li>(void)drawRect:(CGRect)rect{ [super drawRect:rect]; CGContextRef currentContext = UIGraphicsGetCurrentContext(); //设置虚线颜色 CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor); //设置虚线宽度 CGContextSetLineWidth(currentContext, 1); //设置虚线绘制起点 CGContextMoveToPoint(currentContext, 0, 0); //设置虚线绘制终点 CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0); //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点 CGFloat arr[] = {3,1}; //下面最后一个参数“2”代表排列的个数。 CGContextSetLineDash(currentContext, 0, arr, 2); CGContextDrawPath(currentContext, kCGPathStroke); }</li>
</ul>
<p>看着这些代码肯定有一部分人头疼，因为一般开发绘图部分用的比较少，特别是很少接触这些东西的人，甚至对绘图这部分的只是已经忘光了，所以在这里自己也脑补一下。<strong>以下来自转载</strong><br>iOS的绘图操作是在UIView类的drawRect方法中完成的，所以如果我们要想在一个UIView中绘图，需要写一个扩展UIView 的类，并重写drawRect方法，在这里进行绘图操作，程序会自动调用此方法进行绘图。下面先说明一下绘图，比如，你想绘制一个方块，你需要写一个类来扩展UIView并在drawRect方法中填入如下代码：</p>
<ul>
<li>(void)drawRect:(CGRect)rect { // Drawing code. //获得处理的上下文 CGContextRef context = UIGraphicsGetCurrentContext(); //设置线条样式 CGContextSetLineCap(context, kCGLineCapSquare); //设置线条粗细宽度 CGContextSetLineWidth(context, 1.0); //设置颜色 CGContextSetRGBStrokeColor(context, 1.0, 0.0, 0.0, 1.0); //开始一个起始路径 CGContextBeginPath(context); //起始点设置为(0,0):注意这是上下文对应区域中的相对坐标 CGContextMoveToPoint(context, 0, 0); //设置下一个坐标点 CGContextAddLineToPoint(context, 100, 100); //设置下一个坐标点 CGContextAddLineToPoint(context, 0, 150); //设置下一个坐标点 CGContextAddLineToPoint(context, 50, 180); //连接上面定义的坐标点 CGContextStrokePath(context); }</li>
</ul>
<p>再说明一下重绘，重绘操作仍然在drawRect方法中完成，但是苹果不建议直接调用drawRect方法，当然如果你强直直接调用此方法，当然是没有效果的。苹果要求我们调用UIView类中的setNeedsDisplay方法，则程序会自动调用drawRect方法进行重绘（调用setNeedsDisplay会自动调用drawRect）。在UIView中,重写drawRect: (CGRect) aRect方法,可以自己定义想要画的图案.且此方法一般情况下只会画一次.也就是说这个drawRect方法一般情况下只会被掉用一次. 当某些情况下想要手动重画这个View,只需要掉用[self setNeedsDisplay]方法即可.<br>drawRect的执行顺序及注意<br><strong>drawRect调是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的</strong>.<br>如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。</p>
<p>该方法在调用sizeThatFits后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。</p>
<p>通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。</p>
<p>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0.</p>
<p>以上1,2推荐；而3,4不提倡<br>若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect ，让系统自动调该方法。<br>若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法。<br>若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕转载地址：<a href="http://blog.csdn.net/fww330666557/article/details/8647608" target="_blank" rel="noopener">http://blog.csdn.net/fww330666557/article/details/8647608</a></p>
<p>通过UIImage的绘图方法来绘制<br>// 画虚线// 创建一个imageView 高度是你想要的虚线的高度 一般设为2 _lineImg = [[UIImageView alloc] initWithFrame:CGRectMake(0, 20, kScreenWidth, 2)]; // 调用方法 返回的iamge就是虚线 _lineImg.image = [self drawLineByImageView:_lineImg]; // 添加到控制器的view上 [self.view addSubview:_lineImg];// 返回虚线image的方法- (UIImage <em>)drawLineByImageView:(UIImageView </em>)imageView{ UIGraphicsBeginImageContext(imageView.frame.size); //开始画线 划线的frame [imageView.image drawInRect:CGRectMake(0, 0, imageView.frame.size.width, imageView.frame.size.height)]; //设置线条终点形状 CGContextSetLineCap(UIGraphicsGetCurrentContext(), kCGLineCapRound); // 5是每个虚线的长度 1是高度 float lengths[] = {5,1}; CGContextRef line = UIGraphicsGetCurrentContext(); // 设置颜色 CGContextSetStrokeColorWithColor(line, [UIColor colorWithWhite:0.408 alpha:1.000].CGColor); CGContextSetLineDash(line, 0, lengths, 2); //画虚线 CGContextMoveToPoint(line, 0.0, 2.0); //开始画线 CGContextAddLineToPoint(line, kScreenWidth - 10, 2.0); CGContextStrokePath(line); // UIGraphicsGetImageFromCurrentImageContext()返回的就是image return UIGraphicsGetImageFromCurrentImageContext(); }</p>
<p>通过CAShapeLayer方式绘制虚线<br>/<strong> </strong> lineView: 需要绘制成虚线的view <strong> lineLength: 虚线的宽度 </strong> lineSpacing: 虚线的间距 <strong> lineColor: 虚线的颜色 </strong>/+ (void)drawDashLine:(UIView <em>)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor </em>)lineColor{ CAShapeLayer *shapeLayer = [CAShapeLayer layer]; [shapeLayer setBounds:lineView.bounds]; [shapeLayer setPosition:CGPointMake(CGRectGetWidth(lineView.frame) / 2, CGRectGetHeight(lineView.frame))]; [shapeLayer setFillColor:[UIColor clearColor].CGColor]; // 设置虚线颜色为blackColor [shapeLayer setStrokeColor:lineColor.CGColor]; // 设置虚线宽度 [shapeLayer setLineWidth:CGRectGetHeight(lineView.frame)]; [shapeLayer setLineJoin:kCALineJoinRound]; // 设置线宽，线间距 [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]]; // 设置路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 0, 0); CGPathAddLineToPoint(path, NULL,CGRectGetWidth(lineView.frame), 0); [shapeLayer setPath:path]; CGPathRelease(path); // 把绘制好的虚线添加上来 [lineView.layer addSublayer:shapeLayer]; }</p>
<p>这部分代码，有一个注意点：就是position和anchorPoint的区别，这点有兴趣的可以去脑补一下。当然layer上的绘图，我也感觉自己很low了，因为形式没用过，所以基本上快忘光了，所以自己也需要花时间去脑补一下。链接：<a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/" target="_blank" rel="noopener">http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/</a><br>图片平铺（简单暴力）<br>UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@”xuxian.png”]]];[self.view addSubview:imgDashLineView];</p>
<p>作者：Peak_One链接：<a href="http://www.jianshu.com/p/d64b0abef349來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" target="_blank" rel="noopener">http://www.jianshu.com/p/d64b0abef349來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-画虚线的几种方式/" data-id="cjgdiqq71000ckeziziq0ha52" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-聊聊第一响应" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-聊聊第一响应/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-聊聊第一响应/">iOS-聊聊第一响应</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当视图中有UITextField或者UITextView等这些可以输入的视图时，可以用以下代码获取第一响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow];</span><br><span class="line">UIView * _firstResponder = [keyWindow performSelector:@selector(_firstResponder)];</span><br><span class="line">UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)];</span><br><span class="line">UIView *nextResponder = [keyWindow nextResponder];</span><br></pre></td></tr></table></figure></p>
<p>以上获取的_firstResponder与firstResponder是同一对象。可以判断class类型得出第一响应具体是哪一个。<br>nextResponder是其下级响应者，一般都是其父类。</p>
<p>如有新发现会持续更新！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-聊聊第一响应/" data-id="cjgdiqq72000dkeziy4fjilsx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发之多线程GCD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS开发之多线程GCD/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS开发之多线程GCD/">iOS开发之多线程GCD</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####目前多线程主要分为三类：<br> 1 NSThread<br> 2 NSOperation<br> 3 GCD<br>前面两种网上资料很多，本文就苹果推荐使用的GCD理一理。</p>
<h2 id="多线程相关概念"><a href="#多线程相关概念" class="headerlink" title="多线程相关概念"></a>多线程相关概念</h2><p>进程与线程的关系？</p>
<blockquote>
<p>进程：app打开的时候会打开相应的进程，一般情况下，一个App会有一个或多个进程，但是iOS的App一般只有一个进程（后台播放，IM除外）。在iOS系统中，打开一个新的App会挂起其他App的进程。一个进程会包含一个或多个线程。<br>线程：一个线程同时只可以执行一个任务，多线程就可以同时执行多个任务。一个进程可以包含多个线程。</p>
</blockquote>
<p>主线程和子线程（非主线程）到底有什么区别？</p>
<blockquote>
<ul>
<li>主线程：iOS程序中，主线程（又叫作UI线程）主要任务是处理UI事件，显示和刷新UI，（只有主线程有直接修改UI的能力）耗时的操作放在子线程（又叫作后台线程、异步线程）。</li>
<li>子线程：在iOS中开子线程去处理耗时的操作，可以有效提高程序的执行效率，提高资源利用率。</li>
</ul>
</blockquote>
<p>但是开启线程会占用一定的内存，（主线程的堆栈大小是1M，第二个线程开始都是512KB，并且该值不能通过编译器开关或线程API函数来更改）降低程序的性能。所以一般不要同时开很多线程。</p>
<p>注:查看当前线程信息用<strong>[NSThread currentThread]</strong>，而不要用<strong>[NSOperationQueue currentQueue]</strong>，因前者内容可以看到更全面的线程信息！</p>
<p>下面进入正题：</p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h4 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h4><p>(1). 异步与同步</p>
<blockquote>
<p>异步执行：具备开新线程的能力，可以先绕过线程任务，回头再执行。<br>同步执行：不具备开新线程的能力，因此只能在当前线程中执行！任务执行必须按顺序执行（必须执行完当前任务才会继续走代码）。</p>
</blockquote>
<p> (2). 并发队列与串行队列</p>
<blockquote>
<p>并发队列：队列中的任务同时执行(Concurrent Dispatch Queue)<br>串行队列：队列中的任务按添加任务顺序执行(Serial Dispatch Queue)</p>
</blockquote>
<p>注：这里说的任务就是GCD中block中的代码。</p>
<p>这里的关键字一般都是组合用，理解单个是没有意义的，组合后的效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-dbeb080ec6b0f86c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注：如果同步执行的时候，不放入新创建的线程中的话，就会在主线程执行。"><br><strong>以下两种同步执行的情况都是在主线程执行的：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;abcd&quot;, DISPATCH_QUEUE_CONCURRENT);//并发队列</span><br><span class="line">//这里的abcd仅仅作为调试时用的标识符，打印线程属性时并不是name</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    [self loadImage:@10];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    [self loadImage:@11];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    [self loadImage:@12];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    [self loadImage:@13];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 10:38:54.797 多线程GCD[80605:13173361] 执行：10 线程信息：&lt;NSThread: 0x600000073ec0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 10:38:57.342 多线程GCD[80605:13173361] 执行：11 线程信息：&lt;NSThread: 0x600000073ec0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 10:38:59.681 多线程GCD[80605:13173361] 执行：12 线程信息：&lt;NSThread: 0x600000073ec0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 10:39:01.966 多线程GCD[80605:13173361] 执行：13 线程信息：&lt;NSThread: 0x600000073ec0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;aa&quot;, DISPATCH_QUEUE_SERIAL);//串行队列</span><br><span class="line">//这里的DISPATCH_QUEUE_SERIAL等价于NULL</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    [self loadImage:@5];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    [self loadImage:@6];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    [self loadImage:@7];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    [self loadImage:@8];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 10:45:30.928 多线程GCD[81007:13250389] 执行：5 线程信息：&lt;NSThread: 0x600000065000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 10:45:37.232 多线程GCD[81007:13250389] 执行：6 线程信息：&lt;NSThread: 0x600000065000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 10:45:39.713 多线程GCD[81007:13250389] 执行：7 线程信息：&lt;NSThread: 0x600000065000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 10:45:42.314 多线程GCD[81007:13250389] 执行：8 线程信息：&lt;NSThread: 0x600000065000&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>正确的打开方式：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;aa&quot;, DISPATCH_QUEUE_SERIAL);//串行队列</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;abcd&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@5];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@6];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@7];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@8];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 10:47:15.677 多线程GCD[81128:13270066] 执行：5 线程信息：&lt;NSThread: 0x60800007e000&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:47:18.103 多线程GCD[81128:13270066] 执行：6 线程信息：&lt;NSThread: 0x60800007e000&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:47:20.470 多线程GCD[81128:13270066] 执行：7 线程信息：&lt;NSThread: 0x60800007e000&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:47:22.774 多线程GCD[81128:13270066] 执行：8 线程信息：&lt;NSThread: 0x60800007e000&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>以上说的是同步的时候需要注意的，下面说一下异步的情况：</strong><br>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;aa&quot;, DISPATCH_QUEUE_SERIAL);//串行队列</span><br><span class="line">    </span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@0];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@1];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@2];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        [self loadImage:@3];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 10:49:14.498 多线程GCD[81251:13288476] 执行：0 线程信息：&lt;NSThread: 0x600000262680&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:49:17.125 多线程GCD[81251:13288476] 执行：1 线程信息：&lt;NSThread: 0x600000262680&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:49:19.599 多线程GCD[81251:13288476] 执行：2 线程信息：&lt;NSThread: 0x600000262680&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:49:21.934 多线程GCD[81251:13288476] 执行：3 线程信息：&lt;NSThread: 0x600000262680&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;abcd&quot;, DISPATCH_QUEUE_CONCURRENT);//并发队列</span><br><span class="line">    </span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        [self loadImage:@0];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        [self loadImage:@1];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        [self loadImage:@2];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        [self loadImage:@3];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 10:54:06.805 多线程GCD[81549:13342819] 执行：1 线程信息：&lt;NSThread: 0x608000072f80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-06-28 10:54:06.805 多线程GCD[81549:13341379] 执行：0 线程信息：&lt;NSThread: 0x60800007b200&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 10:54:06.805 多线程GCD[81549:13342821] 执行：3 线程信息：&lt;NSThread: 0x6080000743c0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2017-06-28 10:54:06.805 多线程GCD[81549:13342820] 执行：2 线程信息：&lt;NSThread: 0x60000026a400&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p>在串行队列异步执行过程中，会创建一个线程，按顺序执行当前线程中的任务。有阻塞！<br>在并发队列异步执行过程中，可能会创建多个线程，同时执行当前线程中的任务。没有阻塞！</p>
<p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_create(&quot;aaa&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self loadImage:@0];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;bbb&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self loadImage:@1];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;ccc&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self loadImage:@2];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;ddd&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self loadImage:@3];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;eee&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">    [self loadImage:@4];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 11:05:10.966 多线程GCD[82282:13469275] 执行：2 线程信息：&lt;NSThread: 0x608000076100&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-06-28 11:05:10.966 多线程GCD[82282:13469905] 执行：4 线程信息：&lt;NSThread: 0x6080000738c0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2017-06-28 11:05:10.966 多线程GCD[82282:13469278] 执行：3 线程信息：&lt;NSThread: 0x608000075b40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2017-06-28 11:05:10.966 多线程GCD[82282:13469331] 执行：1 线程信息：&lt;NSThread: 0x600000076d00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-06-28 11:05:10.966 多线程GCD[82282:13469276] 执行：0 线程信息：&lt;NSThread: 0x60800006dcc0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上会创建5个串行队列线程，而不是1个串行队列线程，因为不是同一个线程，所以执行顺序是同时执行，互相没有影响(对于并发队列是同样的)。<br>正确使用方法应该是1中创建的方式，对于并发队列，计算机会根据性能和需要创建合理的线程数量。保证系统高性能和流畅性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_create(&quot;a&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    [self loadImage:@14];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;b&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    [self loadImage:@15];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;c&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    [self loadImage:@16];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_queue_create(&quot;d&quot;, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class="line">    [self loadImage:@17];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 11:03:51.193 多线程GCD[82177:13453338] 执行：15 线程信息：&lt;NSThread: 0x608000263040&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-06-28 11:03:51.193 多线程GCD[82177:13449499] 执行：14 线程信息：&lt;NSThread: 0x608000261580&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 11:03:51.193 多线程GCD[82177:13453339] 执行：16 线程信息：&lt;NSThread: 0x608000272f00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-06-28 11:03:51.193 多线程GCD[82177:13453340] 执行：17 线程信息：&lt;NSThread: 0x60000026e740&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>###Main Dispatch Queue/Global Dispatch Queue<br>实际上不用特意生成Dispatch Queue，系统也会为我们准备几个。那就是Main Dispatch Queue和Global Dispatch Queue。</p>
<blockquote>
<p>Main Dispatch Queue就是主线程，因为主线程只有一个，所以Main Dispatch Queue是Serial Dispatch Queue。Main Dispatch Queue的处理在主线程的Runloop中执行。</p>
</blockquote>
<p>相应的，Global Dispatch Queue是系统为我们准备的Concurrent Dispatch Queue。Global Dispatch Queue有四个优先级，应根据需求使用对应优先级。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-8b89934a89887dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优先级.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  high优先级的获取方法</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t globalHighQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line"> /**</span><br><span class="line">  default优先级的获取方法</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t globalDefaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"> /**</span><br><span class="line">  low优先级的获取方法</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t globalLowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line"> /**</span><br><span class="line">  background优先级的获取方法</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br></pre></td></tr></table></figure></p>
<p><strong>更改队列优先级：dispatch_set_target_queue(dispatch_object_t  _Nonnull object, dispatch_queue_t  _Nullable queue)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;aa&quot;, DISPATCH_QUEUE_SERIAL);//串行队列</span><br><span class="line">   </span><br><span class="line">dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br><span class="line">   </span><br><span class="line">dispatch_set_target_queue(serialQueue, globalBackgroundQueue);将serialQueue指定为globalBackgroundQueue用。</span><br></pre></td></tr></table></figure></p>
<p>注：如果这里用函数dispatch_set_target_queue将多个Serial Dispatch Queue指定为同一个Serial Dispatch Queue，就会将原本并发的队列变更为串行队列。</p>
<p>#####关键字 Dispatch Group<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">将原本在serialQueue中要执行的放在group里，后面可以加一个结束的回调（很多时候会有这种需求）</span><br><span class="line">*/</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_group_async(group, serialQueue, ^&#123;</span><br><span class="line">        //代码</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, serialQueue, ^&#123;</span><br><span class="line">        //代码</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, serialQueue, ^&#123;</span><br><span class="line">        //代码</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;done&quot;);//执行完成后回调</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>#####关键字 dispatch_barrier_async 栅栏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;abcd&quot;, DISPATCH_QUEUE_CONCURRENT);//并行队列</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@0];</span><br><span class="line">       //读取数据0</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@1];</span><br><span class="line">       //读取数据1</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@2];</span><br><span class="line">       //读取数据2</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@3];</span><br><span class="line">       //读取数据3</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@4];</span><br><span class="line">      //异步栅栏写入数据4</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_barrier_sync(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@4];</span><br><span class="line">       //同步栅栏写入数据4</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@5];</span><br><span class="line">       //读取数据5</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@6];</span><br><span class="line">       //读取数据6</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@7];</span><br><span class="line">       //读取数据7</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">       [self loadImage:@8];</span><br><span class="line">       //读取数据8</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2017-06-28 11:11:53.029 多线程GCD[82699:13543714] 执行：2 线程信息：&lt;NSThread: 0x600000076d80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-06-28 11:11:53.029 多线程GCD[82699:13543650] 执行：0 线程信息：&lt;NSThread: 0x600000076d40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 11:11:53.029 多线程GCD[82699:13543652] 执行：1 线程信息：&lt;NSThread: 0x608000066940&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-06-28 11:11:53.029 多线程GCD[82699:13543715] 执行：3 线程信息：&lt;NSThread: 0x608000071140&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2017-06-28 11:11:58.763 多线程GCD[82699:13544668] 异步栅栏执行：4 线程信息：&lt;NSThread: 0x6080000710c0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2017-06-28 11:12:01.195 多线程GCD[82699:13542941] 同步栅栏执行：4 线程信息：&lt;NSThread: 0x600000066500&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-06-28 11:12:03.605 多线程GCD[82699:13543650] 执行：7 线程信息：&lt;NSThread: 0x600000076d40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-06-28 11:12:03.605 多线程GCD[82699:13544677] 执行：5 线程信息：&lt;NSThread: 0x608000074bc0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2017-06-28 11:12:03.605 多线程GCD[82699:13544668] 执行：6 线程信息：&lt;NSThread: 0x6080000710c0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2017-06-28 11:12:03.605 多线程GCD[82699:13543714] 执行：8 线程信息：&lt;NSThread: 0x600000076d80&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p>在读取数据时，有时候会出现数据竞争，数据安全问题，比如：当前的写入没有结束，读取操作就开始处理，导致数据错乱。或者读取正在进行，开始写入操作，导致程序崩溃等问题。<br>苹果为我们提供了一个便捷的参数：dispatch_barrier_async（栅栏）。</p>
<blockquote>
<p><strong>作用</strong>：如上述代码中所表示，只有在1234操作完成时（无序），才会执行写入操作，只有当前写入操作结束后，才会继续向下执行。dispatch_barrier_sync也有同样的效果，但是如果不放入其他线程中的话，会在当前线程即主线程执行，会阻塞线程。</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong>dispatch_barrier_async中如果使用全局队列的话，就相当于要等待全局队列里的所有并发任务执行完后，才会执行dispatch_barrier_async中的任务，这样会受其他在全局队列里任务的影响，达不到我们想要的效果。</p>
</blockquote>
<p>总结：<br> <strong><br>并发队列(Concurrent Dispatch Queue)  串行队列(Serial Dispatch Queue) ：<br>负责执行顺序！<br>异步执行 (dispatch_async)  同步执行 (dispatch_sync)：<br>负责选择线程执行！
</strong></p>
<p>上一篇：<a href="http://www.jianshu.com/p/b1e940281c6f" target="_blank" rel="noopener">iOS开发系列:让你的应用“动”起来–Core Animation</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS开发之多线程GCD/" data-id="cjgdiqq73000ekezid4inl0mv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发常用数学函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS开发常用数学函数/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS开发常用数学函数/">iOS开发常用数学函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>三角函数<br>　　double sin (double);正弦<br>　　double cos (double);余弦<br>　　double tan (double);正切 </li>
<li>反三角函数<br>　　double asin (double); 结果介于[-PI/2, PI/2]<br>　　double acos (double); 结果介于[0, PI]<br>　　double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2]<br>　　double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] </li>
<li>双曲三角函数<br>　　double sinh (double);<br>　　double cosh (double);<br>　　double tanh (double); </li>
<li>指数与对数<br>　　double exp (double);求取自然数e的幂<br>　　double sqrt (double);开平方<br>　　double log (double); 以e为底的对数<br>　　double log10 (double);以10为底的对数<br>　　double pow(double x, double y）;计算以x为底数的y次幂<br>　　float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 </li>
<li>取整<br>　　double ceil (double); 取上整<br>　　double floor (double); 取下整 </li>
<li>绝对值<br>　　double fabs (double);求绝对值<br>　　double cabs(struct complex znum) ;求复数的绝对值 </li>
<li>标准化浮点数<br>　　double frexp (double f, int <em>p); 标准化浮点数, f = x </em> 2^p, 已知f求x, p ( x介于[0.5, 1] )<br>　　double ldexp (double x, int p); 与frexp相反, 已知x, p求f </li>
<li>取整与取余<br>　　double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分<br>　　double fmod (double, double); 返回两参数相除的余数 </li>
<li>其他<br>　　double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度<br>　　double ldexp(double x, int exponent);计算x<em>(2的exponent次幂)<br>　　double poly(double x, int degree, double coeffs [] );计算多项式<br>　　nt matherr(struct exception </em>e);数学错误计算处理程序</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS开发常用数学函数/" data-id="cjgdiqq74000gkezij17du5sm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发系列-让你的应用“动”起来--Core-Animation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS开发系列-让你的应用“动”起来--Core-Animation/" class="article-date">
  <time datetime="2018-04-24T09:46:20.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS开发系列-让你的应用“动”起来--Core-Animation/">iOS开发系列-让你的应用“动”起来--Core-Animation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大家都知道在iOS中实现一个动画相当简单，只要调用UIView的块代码即可实现一个动画效果，这在其他系统开发中基本不可能实现。下面通过一个简单的UIView进行一个图片放大动画效果演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    UIImage *image=[UIImage imageNamed:@&quot;open2.png&quot;];</span><br><span class="line">    UIImageView *imageView=[[UIImageView alloc]init];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">    imageView.frame=CGRectMake(120, 140, 80, 80);</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line">    </span><br><span class="line">    //两秒后开始一个持续一分钟的动画</span><br><span class="line">    [UIView animateWithDuration:1 delay:2 options:UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</span><br><span class="line">        imageView.frame=CGRectMake(80, 100, 160, 160);</span><br><span class="line">    &#125; completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>使用上面UIView封装的方法进行动画设置固然十分方便，但是具体动画如何实现我们是不清楚的，而且上面的代码还有一些问题是无法解决的，例如：如何控制动画的暂停？如何进行动画的组合？？？</p>
<p>这里就需要了解iOS的核心动画Core Animation（包含在Quartz Core框架中）。在iOS中核心动画分为几类：基础动画、关键帧动画、动画组、转场动画。各个类的关系大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-36092b5328dbce1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li><p>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>
</li>
<li><p>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</p>
</li>
<li><p>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>
</li>
<li><p>CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>
</li>
<li><p>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>
</li>
<li><p>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>
</li>
</ul>
<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>
<p>#基础动画</p>
<p>在开发过程中很多情况下通过基础动画就可以满足开发需求，前面例子中使用的UIView代码块进行图像放大缩小的演示动画也是基础动画（在iOS7中UIView也对关键帧动画进行了封装），只是UIView装饰方法隐藏了更多的细节。如果不使用UIView封装的方法，动画创建一般分为以下几步：</p>
<ol>
<li>初始化动画并设置动画属性</li>
<li>设置动画属性初始值（可以省略）、结束值以及其他动画属性</li>
<li>给图层添加动画</li>
</ol>
<p>下面以一个移动动画为例进行演示，在这个例子中点击屏幕哪个位置落花将飞向哪里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[CALayer layer];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 移动动画</span><br><span class="line">-(void)translatonAnimation:(CGPoint)location&#123;</span><br><span class="line">    //1.创建动画并指定动画属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画属性初始值和结束值</span><br><span class="line">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span><br><span class="line">    basicAnimation.toValue=[NSValue valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    //设置其他动画属性</span><br><span class="line">    basicAnimation.duration=5.0;//动画时间5秒</span><br><span class="line">    //basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span><br><span class="line">    //    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //3.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:@&quot;KCBasicAnimation_Translation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 点击事件</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    UITouch *touch=touches.anyObject;</span><br><span class="line">    CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    //创建并开始动画</span><br><span class="line">    [self translatonAnimation:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-b9a0bf42a4083205.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>上面实现了一个基本动画效果，但是这个动画存在一个问题：动画结束后动画图层回到了原来的位置，当然是用UIView封装的方法是没有这个问题的。如何解决这个问题呢？</p>
<p>图层动画的本质就是将图层内部的内容转化为位图经硬件操作形成一种动画效果，其实图层本身并没有任何的变化。上面的动画中图层并没有因为动画效果而改变它的位置（对于缩放动画其大小也是不会改变的），所以动画完成之后图层还是在原来的显示位置没有任何变化，如果这个图层在一个UIView中你会发现在UIView移动过程中你要触发UIView的点击事件也只能点击原来的位置（即使它已经运动到了别的位置），因为它的位置从来没有变过。当然解决这个问题方法比较多，这里不妨在动画完成之后重新设置它的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// </span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&lt;CAAnimationDelegate&gt;&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 移动动画</span><br><span class="line">-(void)translatonAnimation:(CGPoint)location&#123;</span><br><span class="line">    //1.创建动画并指定动画属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画属性初始值和结束值</span><br><span class="line">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span><br><span class="line">    basicAnimation.toValue=[NSValue valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    //设置其他动画属性</span><br><span class="line">    basicAnimation.duration=5.0;//动画时间5秒</span><br><span class="line">    //basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span><br><span class="line">    //    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span><br><span class="line">    basicAnimation.delegate=self;</span><br><span class="line">    //存储当前位置在动画结束后使用</span><br><span class="line">    [basicAnimation setValue:[NSValue valueWithCGPoint:location] forKey:@&quot;KCBasicAnimationLocation&quot;];</span><br><span class="line">    </span><br><span class="line">    //3.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:@&quot;KCBasicAnimation_Translation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 点击事件</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    UITouch *touch=touches.anyObject;</span><br><span class="line">    CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    //创建并开始动画</span><br><span class="line">    [self translatonAnimation:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 动画代理方法</span><br><span class="line">#pragma mark 动画开始</span><br><span class="line">-(void)animationDidStart:(CAAnimation *)anim&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) start.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_layer animationForKey:@&quot;KCBasicAnimation_Translation&quot;]);//通过前面的设置的key获得动画</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 动画结束</span><br><span class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) stop.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    _layer.position=[[anim valueForKey:@&quot;KCBasicAnimationLocation&quot;] CGPointValue];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>上面通过给动画设置一个代理去监听动画的开始和结束事件，在动画开始前给动画添加一个自定义属性“KCBasicAnimationLocation”存储动画终点位置，然后在动画结束后设置动画的位置为终点位置。</p>
<p>如果运行上面的代码大家可能会发现另外一个问题，那就是动画运行完成后会重新从起始点运动到终点。这个问题产生的原因就是前面提到的，对于非根图层，设置图层的可动画属性（在动画结束后重新设置了position，而position是可动画属性）会产生动画效果。解决这个问题有两种办法：关闭图层隐式动画、设置动画图层为根图层。显然这里不能采取后者，因为根图层当前已经作为动画的背景。</p>
<p>要关闭隐式动画需要用到动画事务CATransaction，在事务内将隐式动画关闭，例如上面的代码可以改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 动画结束</span><br><span class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) stop.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    //开启事务</span><br><span class="line">    [CATransaction begin];</span><br><span class="line">    //禁用隐式动画</span><br><span class="line">    [CATransaction setDisableActions:YES];</span><br><span class="line">    </span><br><span class="line">    _layer.position=[[anim valueForKey:@&quot;KCBasicAnimationLocation&quot;] CGPointValue];</span><br><span class="line">    </span><br><span class="line">    //提交事务</span><br><span class="line">    [CATransaction commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然上面的动画还显得有些生硬，因为落花飘散的时候可能不仅仅是自由落体运动，本身由于空气阻力、外界风力还会造成落花在空中的旋转、摇摆等，这里不妨给图层添加一个旋转的动画。对于图层的旋转通过key path设置图层旋转的内容，在这里需要强调一下，图层的形变都是基于锚点进行的。例如旋转，旋转的中心点就是图层的锚点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.anchorPoint=CGPointMake(0.5, 0.6);//设置锚点</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 移动动画</span><br><span class="line">-(void)translatonAnimation:(CGPoint)location&#123;</span><br><span class="line">    //1.创建动画并指定动画属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画属性初始值、结束值</span><br><span class="line">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span><br><span class="line">    basicAnimation.toValue=[NSValue valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    //设置其他动画属性</span><br><span class="line">    basicAnimation.duration=5.0;//动画时间5秒</span><br><span class="line">    //basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span><br><span class="line">    //    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span><br><span class="line">    basicAnimation.delegate=self;</span><br><span class="line">    //存储当前位置在动画结束后使用</span><br><span class="line">    [basicAnimation setValue:[NSValue valueWithCGPoint:location] forKey:@&quot;KCBasicAnimationLocation&quot;];</span><br><span class="line">    </span><br><span class="line">    //3.添加动画到图层，注意key相当于给动画进行命名，以后获得该图层时可以使用此名称获取</span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:@&quot;KCBasicAnimation_Translation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 旋转动画</span><br><span class="line">-(void)rotationAnimation&#123;</span><br><span class="line">    //1.创建动画并指定动画属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画属性初始值、结束值</span><br><span class="line">//    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];</span><br><span class="line">    basicAnimation.toValue=[NSNumber numberWithFloat:M_PI_2*3];</span><br><span class="line">    </span><br><span class="line">    //设置其他动画属性</span><br><span class="line">    basicAnimation.duration=6.0;</span><br><span class="line">    basicAnimation.autoreverses=true;//旋转后再旋转到原来的位置</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:@&quot;KCBasicAnimation_Rotation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 点击事件</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    UITouch *touch=touches.anyObject;</span><br><span class="line">    CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    //创建并开始动画</span><br><span class="line">    [self translatonAnimation:location];</span><br><span class="line">    </span><br><span class="line">    [self rotationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 动画代理方法</span><br><span class="line">#pragma mark 动画开始</span><br><span class="line">-(void)animationDidStart:(CAAnimation *)anim&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) start.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_layer animationForKey:@&quot;KCBasicAnimation_Translation&quot;]);//通过前面的设置的key获得动画</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 动画结束</span><br><span class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) stop.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    //开启事务</span><br><span class="line">    [CATransaction begin];</span><br><span class="line">    //禁用隐式动画</span><br><span class="line">    [CATransaction setDisableActions:YES];</span><br><span class="line">    </span><br><span class="line">    _layer.position=[[anim valueForKey:@&quot;KCBasicAnimationLocation&quot;] CGPointValue];</span><br><span class="line">    </span><br><span class="line">    //提交事务</span><br><span class="line">    [CATransaction commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>上面代码中结合两种动画操作，需要注意的是只给移动动画设置了代理，在旋转动画中并没有设置代理，否则代理方法会执行两遍。由于旋转动画会无限循环执行（上面设置了重复次数无穷大），并且两个动画的执行时间没有必然的关系，这样一来移动停止后可能还在旋转，为了让移动动画停止后旋转动画停止就需要使用到动画的暂停和恢复方法。</p>
<p>核心动画的运行有一个媒体时间的概念，假设将一个旋转动画设置旋转一周用时60秒的话，那么当动画旋转90度后媒体时间就是15秒。如果此时要将动画暂停只需要让媒体时间偏移量设置为15秒即可，并把动画运行速度设置为0使其停止运动。类似的，如果又过了60秒后需要恢复动画（此时媒体时间为75秒），这时只要将动画开始开始时间设置为当前媒体时间75秒减去暂停时的时间（也就是之前定格动画时的偏移量）15秒（开始时间=75-15=60秒），那么动画就会重新计算60秒后的状态再开始运行，与此同时将偏移量重新设置为0并且把运行速度设置1。这个过程中真正起到暂停动画和恢复动画的其实是动画速度的调整，媒体时间偏移量以及恢复时的开始时间设置主要为了让动画更加连贯。</p>
<p>下面的代码演示了移动动画结束后旋转动画暂停，并且当再次点击动画时旋转恢复的过程(注意在移动过程中如果再次点击屏幕可以暂停移动和旋转动画，再次点击可以恢复两种动画。但是当移动结束后触发了移动动画的完成事件如果再次点击屏幕则只能恢复旋转动画，因为此时移动动画已经结束而不是暂停，无法再恢复)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.anchorPoint=CGPointMake(0.5, 0.6);//设置锚点</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark 移动动画</span><br><span class="line">-(void)translatonAnimation:(CGPoint)location&#123;</span><br><span class="line">    //1.创建动画并指定动画属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画属性初始值、结束值</span><br><span class="line">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span><br><span class="line">    basicAnimation.toValue=[NSValue valueWithCGPoint:location];</span><br><span class="line">    </span><br><span class="line">    //设置其他动画属性</span><br><span class="line">    basicAnimation.duration=5.0;//动画时间5秒</span><br><span class="line">//    basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span><br><span class="line">    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span><br><span class="line">    basicAnimation.delegate=self;</span><br><span class="line">    //存储当前位置在动画结束后使用</span><br><span class="line">    [basicAnimation setValue:[NSValue valueWithCGPoint:location] forKey:@&quot;KCBasicAnimationLocation&quot;];</span><br><span class="line">    </span><br><span class="line">    //3.添加动画到图层，注意key相当于给动画进行命名，以后获得该图层时可以使用此名称获取</span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:@&quot;KCBasicAnimation_Translation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 旋转动画</span><br><span class="line">-(void)rotationAnimation&#123;</span><br><span class="line">    //1.创建动画并指定动画属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画属性初始值、结束值</span><br><span class="line">//    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];</span><br><span class="line">    basicAnimation.toValue=[NSNumber numberWithFloat:M_PI_2*3];</span><br><span class="line">    </span><br><span class="line">    //设置其他动画属性</span><br><span class="line">    basicAnimation.duration=6.0;</span><br><span class="line">    basicAnimation.autoreverses=true;//旋转后在旋转到原来的位置</span><br><span class="line">    basicAnimation.repeatCount=HUGE_VALF;//设置无限循环</span><br><span class="line">    basicAnimation.removedOnCompletion=NO;</span><br><span class="line">//    basicAnimation.delegate=self;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:@&quot;KCBasicAnimation_Rotation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 点击事件</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    UITouch *touch=touches.anyObject;</span><br><span class="line">    CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    //判断是否已经创建过动画，如果已经创建则不再创建动画</span><br><span class="line">    CAAnimation *animation= [_layer animationForKey:@&quot;KCBasicAnimation_Translation&quot;];</span><br><span class="line">    if(animation)&#123;</span><br><span class="line">        if (_layer.speed==0) &#123;</span><br><span class="line">            [self animationResume];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            [self animationPause];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //创建并开始动画</span><br><span class="line">        [self translatonAnimation:location];</span><br><span class="line">        </span><br><span class="line">        [self rotationAnimation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 动画暂停</span><br><span class="line">-(void)animationPause&#123;</span><br><span class="line">    //取得指定图层动画的媒体时间，后面参数用于指定子图层，这里不需要</span><br><span class="line">    CFTimeInterval interval=[_layer convertTime:CACurrentMediaTime() fromLayer:nil];</span><br><span class="line">    //设置时间偏移量，保证暂停时停留在旋转的位置</span><br><span class="line">    [_layer setTimeOffset:interval];</span><br><span class="line">    //速度设置为0，暂停动画</span><br><span class="line">    _layer.speed=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 动画恢复</span><br><span class="line">-(void)animationResume&#123;</span><br><span class="line">    //获得暂停的时间</span><br><span class="line">    CFTimeInterval beginTime= CACurrentMediaTime()- _layer.timeOffset;</span><br><span class="line">    //设置偏移量</span><br><span class="line">    _layer.timeOffset=0;</span><br><span class="line">    //设置开始时间</span><br><span class="line">    _layer.beginTime=beginTime;</span><br><span class="line">    //设置动画速度，开始运动</span><br><span class="line">    _layer.speed=1.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 动画代理方法</span><br><span class="line">#pragma mark 动画开始</span><br><span class="line">-(void)animationDidStart:(CAAnimation *)anim&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) start.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_layer animationForKey:@&quot;KCBasicAnimation_Translation&quot;]);//通过前面的设置的key获得动画</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 动画结束</span><br><span class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</span><br><span class="line">    NSLog(@&quot;animation(%@) stop.\r_layer.frame=%@&quot;,anim,NSStringFromCGRect(_layer.frame));</span><br><span class="line">    </span><br><span class="line">    //开启事务</span><br><span class="line">    [CATransaction begin];</span><br><span class="line">    //禁用隐式动画</span><br><span class="line">    [CATransaction setDisableActions:YES];</span><br><span class="line">    </span><br><span class="line">    _layer.position=[[anim valueForKey:@&quot;KCBasicAnimationLocation&quot;] CGPointValue];</span><br><span class="line">    </span><br><span class="line">    //提交事务</span><br><span class="line">    [CATransaction commit];</span><br><span class="line">    </span><br><span class="line">    //暂停动画</span><br><span class="line">    [self animationPause];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-f627e183ce0a4381.gif?imageMogr2/auto-orient/strip" alt=""></p>
<blockquote>
<p>注意：<br>动画暂停针对的是图层而不是图层中的某个动画。<br>要做无限循环的动画，动画的removedOnCompletion属性必须设置为NO，否则运行一次动画就会销毁。</p>
</blockquote>
<p>##关键帧动画</p>
<p>熟悉flash开发的朋友对于关键帧动画应该不陌生，这种动画方式在flash开发中经常用到。关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>
<p>关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>
<p>对于前面的落花动画效果而言其实落花的过程并不自然，很显然实际生活中它不可能沿着直线下落，这里我们不妨通过关键帧动画的values属性控制它在下落过程中的属性。假设下落过程如图：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-c4ffa126403764fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在这里需要设置四个关键帧（如图中四个关键点），具体代码如下（动画创建过程同基本动画基本完全一致）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    //创建动画</span><br><span class="line">    [self translationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 关键帧动画</span><br><span class="line">-(void)translationAnimation&#123;</span><br><span class="line">    //1.创建关键帧动画并设置动画属性</span><br><span class="line">    CAKeyframeAnimation *keyframeAnimation=[CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置关键帧,这里有四个关键帧</span><br><span class="line">    NSValue *key1=[NSValue valueWithCGPoint:_layer.position];//对于关键帧动画初始值不能省略</span><br><span class="line">    NSValue *key2=[NSValue valueWithCGPoint:CGPointMake(80, 220)];</span><br><span class="line">    NSValue *key3=[NSValue valueWithCGPoint:CGPointMake(45, 300)];</span><br><span class="line">    NSValue *key4=[NSValue valueWithCGPoint:CGPointMake(55, 400)];</span><br><span class="line">    NSArray *values=@[key1,key2,key3,key4];</span><br><span class="line">    keyframeAnimation.values=values;</span><br><span class="line">    //设置其他属性</span><br><span class="line">    keyframeAnimation.duration=8.0;</span><br><span class="line">    keyframeAnimation.beginTime=CACurrentMediaTime()+2;//设置延迟2秒执行</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //3.添加动画到图层，添加动画后就会执行动画</span><br><span class="line">    [_layer addAnimation:keyframeAnimation forKey:@&quot;KCKeyframeAnimation_Position&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行效果(注意运行结束没有设置图层位置为动画运动结束位置)：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-941247dd1569c6df.gif?imageMogr2/auto-orient/strip" alt=""><br>上面的方式固然比前面使用基础动画效果要好一些，但其实还是存在问题，那就是落花飞落的路径是直线的，当然这个直线是根据程序中设置的四个关键帧自动形成的，那么如何让它沿着曲线飘落呢？这就是第二种类型的关键帧动画，通过描绘路径进行关键帧动画控制。假设让落花沿着下面的曲线路径飘落：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-b4e8e00aa8a85236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>当然，这是一条贝塞尔曲线，学习了前篇文章之后相信对于这类曲线应该并不陌生，下面是具体实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    //创建动画</span><br><span class="line">    [self translationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 关键帧动画</span><br><span class="line">-(void)translationAnimation&#123;</span><br><span class="line">    //1.创建关键帧动画并设置动画属性</span><br><span class="line">    CAKeyframeAnimation *keyframeAnimation=[CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    //2.设置路径</span><br><span class="line">    //绘制贝塞尔曲线</span><br><span class="line">    CGPathRef path=CGPathCreateMutable();</span><br><span class="line">    CGPathMoveToPoint(path, NULL, _layer.position.x, _layer.position.y);//移动到起始点</span><br><span class="line">    CGPathAddCurveToPoint(path, NULL, 160, 280, -30, 300, 55, 400);//绘制二次贝塞尔曲线</span><br><span class="line"></span><br><span class="line">    keyframeAnimation.path=path;//设置path属性</span><br><span class="line">    CGPathRelease(path);//释放路径对象</span><br><span class="line">    //设置其他属性</span><br><span class="line">    keyframeAnimation.duration=8.0;</span><br><span class="line">    keyframeAnimation.beginTime=CACurrentMediaTime()+5;//设置延迟2秒执行</span><br><span class="line">    </span><br><span class="line">    //3.添加动画到图层，添加动画后就会执行动画</span><br><span class="line">    [_layer addAnimation:keyframeAnimation forKey:@&quot;KCKeyframeAnimation_Position&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行效果(注意运行结束没有设置图层位置为动画运动结束位置)：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-2d9d35fbcc89e9a8.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>看起来动画不会那么生硬了，但是这里需要注意，对于路径类型的关键帧动画系统是从描绘路径的位置开始路径，直到路径结束。如果上面的路径不是贝塞尔曲线而是矩形路径那么它会从矩形的左上角开始运行，顺时针一周回到左上角；如果指定的路径是一个椭圆，那么动画运行的路径是从椭圆右侧开始（0度）顺时针一周回到右侧。</p>
<p>####补充–其他属性</p>
<p>在关键帧动画中还有一些动画属性初学者往往比较容易混淆，这里专门针对这些属性做一下介绍。</p>
<p>keyTimes：各个关键帧的时间控制。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</p>
<p>caculationMode：动画计算模式。还拿上面keyValues动画举例，之所以1到2帧能形成连贯性动画而不是直接从第1帧经过8/3秒到第2帧是因为动画模式是连续的（值为kCAAnimationLinear，这是计算模式的默认值）；而如果指定了动画模式为kCAAnimationDiscrete离散的那么你会看到动画从第1帧经过8/3秒直接到第2帧，中间没有任何过渡。其他动画模式还有：kCAAnimationPaced（均匀执行，会忽略keyTimes）、kCAAnimationCubic（平滑执行，对于位置变动关键帧动画运行轨迹更平滑）、kCAAnimationCubicPaced（平滑均匀执行）。</p>
<p>下图描绘出了几种动画模式的关系（横坐标是运行时间，纵坐标是动画属性[例如位置、透明度等]）：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-dd25d87f7b76f972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###动画组<br>实际开发中一个物体的运动往往是复合运动，单一属性的运动情况比较少，但恰恰属性动画每次进行动画设置时一次只能设置一个属性进行动画控制(不管是基础动画还是关键帧动画都是如此)，这样一来要做一个复合运动的动画就必须创建多个属性动画进行组合。对于一两种动画的组合或许处理起来还比较容易，但是对于更多动画的组合控制往往会变得很麻烦，动画组的产生就是基于这样一种情况而产生的。动画组是一系列动画的组合，凡是添加到动画组中的动画都受控于动画组，这样一来各类动画公共的行为就可以统一进行控制而不必单独设置，而且放到动画组中的各个动画可以并发执行，共同构建出复杂的动画效果。</p>
<p>动画组使用起来并不复杂，首先单独创建单个动画（可以是基础动画也可以是关键帧动画），然后将基础动画添加到动画组，最后将动画组添加到图层即可。</p>
<p>前面关键帧动画部分，路径动画看起来效果虽然很流畅，但是落花本身的旋转运动没有了，这里不妨将基础动画部分的旋转动画和路径关键帧动画进行组合使得整个动画看起来更加的和谐、顺畅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景(注意这个图片其实在根图层)</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    //自定义一个图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 10, 20);</span><br><span class="line">    _layer.position=CGPointMake(50, 150);</span><br><span class="line">    _layer.contents=(id)[UIImage imageNamed:@&quot;petal.png&quot;].CGImage;</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    //创建动画</span><br><span class="line">    [self groupAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 基础旋转动画</span><br><span class="line">-(CABasicAnimation *)rotationAnimation&#123;</span><br><span class="line"></span><br><span class="line">    CABasicAnimation *basicAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line"></span><br><span class="line">    CGFloat toValue=M_PI_2*3;</span><br><span class="line">    basicAnimation.toValue=[NSNumber numberWithFloat:M_PI_2*3];</span><br><span class="line"></span><br><span class="line">//    basicAnimation.duration=6.0;</span><br><span class="line">    basicAnimation.autoreverses=true;</span><br><span class="line">    basicAnimation.repeatCount=HUGE_VALF;</span><br><span class="line">    basicAnimation.removedOnCompletion=NO;</span><br><span class="line">    </span><br><span class="line">    [basicAnimation setValue:[NSNumber numberWithFloat:toValue] forKey:@&quot;KCBasicAnimationProperty_ToValue&quot;];</span><br><span class="line">    </span><br><span class="line">    return basicAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 关键帧移动动画</span><br><span class="line">-(CAKeyframeAnimation *)translationAnimation&#123;</span><br><span class="line">    CAKeyframeAnimation *keyframeAnimation=[CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    </span><br><span class="line">    CGPoint endPoint= CGPointMake(55, 400);</span><br><span class="line">    CGPathRef path=CGPathCreateMutable();</span><br><span class="line">    CGPathMoveToPoint(path, NULL, _layer.position.x, _layer.position.y);</span><br><span class="line">    CGPathAddCurveToPoint(path, NULL, 160, 280, -30, 300, endPoint.x, endPoint.y);</span><br><span class="line">    </span><br><span class="line">    keyframeAnimation.path=path;</span><br><span class="line">    CGPathRelease(path);</span><br><span class="line"></span><br><span class="line">    [keyframeAnimation setValue:[NSValue valueWithCGPoint:endPoint] forKey:@&quot;KCKeyframeAnimationProperty_EndPosition&quot;];</span><br><span class="line">    </span><br><span class="line">    return keyframeAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 创建动画组</span><br><span class="line">-(void)groupAnimation&#123;</span><br><span class="line">    //1.创建动画组</span><br><span class="line">    CAAnimationGroup *animationGroup=[CAAnimationGroup animation];</span><br><span class="line">    </span><br><span class="line">    //2.设置组中的动画和其他属性</span><br><span class="line">    CABasicAnimation *basicAnimation=[self rotationAnimation];</span><br><span class="line">    CAKeyframeAnimation *keyframeAnimation=[self translationAnimation];</span><br><span class="line">    animationGroup.animations=@[basicAnimation,keyframeAnimation];</span><br><span class="line">    </span><br><span class="line">    animationGroup.delegate=self;</span><br><span class="line">    animationGroup.duration=10.0;//设置动画时间，如果动画组中动画已经设置过动画属性则不再生效</span><br><span class="line">    animationGroup.beginTime=CACurrentMediaTime()+5;//延迟五秒执行</span><br><span class="line">    </span><br><span class="line">    //3.给图层添加动画</span><br><span class="line">    [_layer addAnimation:animationGroup forKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 代理方法</span><br><span class="line">#pragma mark 动画完成</span><br><span class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</span><br><span class="line">    CAAnimationGroup *animationGroup=(CAAnimationGroup *)anim;</span><br><span class="line">    CABasicAnimation *basicAnimation=animationGroup.animations[0];</span><br><span class="line">    CAKeyframeAnimation *keyframeAnimation=animationGroup.animations[1];</span><br><span class="line">    CGFloat toValue=[[basicAnimation valueForKey:@&quot;KCBasicAnimationProperty_ToValue&quot;] floatValue];</span><br><span class="line">    CGPoint endPoint=[[keyframeAnimation valueForKey:@&quot;KCKeyframeAnimationProperty_EndPosition&quot;] CGPointValue];</span><br><span class="line">    </span><br><span class="line">    [CATransaction begin];</span><br><span class="line">    [CATransaction setDisableActions:YES];</span><br><span class="line">    </span><br><span class="line">    //设置动画最终状态</span><br><span class="line">    _layer.position=endPoint;</span><br><span class="line">    _layer.transform=CATransform3DMakeRotation(toValue, 0, 0, 1);</span><br><span class="line">    </span><br><span class="line">    [CATransaction commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://upload-images.jianshu.io/upload_images/2647951-f92b3b46d64b191c.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>####转场动画<br>转场动画就是从一个场景以动画的形式过渡到另一个场景。转场动画的使用一般分为以下几个步骤：</p>
<ol>
<li><p>创建转场动画</p>
</li>
<li><p>设置转场类型、子类型（可选）及其他属性</p>
</li>
<li><p>设置转场后的新视图并添加动画到图层</p>
</li>
</ol>
<p>下表列出了常用的转场类型(注意私有API是苹果官方没有公开的动画类型，但是目前通过仍然可以使用)：</p>
<table>
<thead>
<tr>
<th>动画类型</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置     </th>
</tr>
</thead>
<tbody>
<tr>
<td>公开API</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td>fade</td>
<td style="text-align:center">淡出效果</td>
<td style="text-align:center">kCATransitionFade</td>
<td>是</td>
</tr>
<tr>
<td>movein</td>
<td style="text-align:center">新视图移动到旧视图上</td>
<td style="text-align:center">kCATransitionMoveIn</td>
<td>是</td>
</tr>
<tr>
<td>push</td>
<td style="text-align:center">新视图推出旧视图</td>
<td style="text-align:center">kCATransitionPush</td>
<td>是</td>
</tr>
<tr>
<td>reveal</td>
<td style="text-align:center">移开旧视图显示新视图</td>
<td style="text-align:center">kCATransitionReveal</td>
<td>是</td>
</tr>
<tr>
<td>私有API</td>
<td style="text-align:center"></td>
<td style="text-align:center">私有API只能通过字符串访问</td>
<td></td>
</tr>
<tr>
<td>cube</td>
<td style="text-align:center">立方体翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td>oglFlip</td>
<td style="text-align:center">翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td>suckEffect</td>
<td style="text-align:center">收缩效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td>rippleEffect</td>
<td style="text-align:center">水滴波纹效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td>pageCurl</td>
<td style="text-align:center">向上翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td>pageUnCurl</td>
<td style="text-align:center">向下翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td>cameralIrisHollowOpen</td>
<td style="text-align:center">摄像头打开效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td>cameraIrisHollowClose</td>
<td style="text-align:center">摄像头关闭效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>另外对于支持方向设置的动画类型还包含子类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">动画子类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kCATransitionFromRight</td>
<td style="text-align:center">从右侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromLeft</td>
<td style="text-align:center">从左侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromTop</td>
<td style="text-align:center">从顶部转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromBottom</td>
<td style="text-align:center">从底部转场</td>
</tr>
</tbody>
</table>
<p>使用转场动画利用一个UIImageView实现一个漂亮的无限循环图片浏览器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define IMAGE_COUNT 5</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    UIImageView *_imageView;</span><br><span class="line">    int _currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //定义图片控件</span><br><span class="line">    _imageView=[[UIImageView alloc]init];</span><br><span class="line">    _imageView.frame=[UIScreen mainScreen].bounds;</span><br><span class="line">    _imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">    _imageView.image=[UIImage imageNamed:@&quot;0.jpg&quot;];//默认图片</span><br><span class="line">    [self.view addSubview:_imageView];</span><br><span class="line">    //添加手势</span><br><span class="line">    UISwipeGestureRecognizer *leftSwipeGesture=[[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(leftSwipe:)];</span><br><span class="line">    leftSwipeGesture.direction=UISwipeGestureRecognizerDirectionLeft;</span><br><span class="line">    [self.view addGestureRecognizer:leftSwipeGesture];</span><br><span class="line">    </span><br><span class="line">    UISwipeGestureRecognizer *rightSwipeGesture=[[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(rightSwipe:)];</span><br><span class="line">    rightSwipeGesture.direction=UISwipeGestureRecognizerDirectionRight;</span><br><span class="line">    [self.view addGestureRecognizer:rightSwipeGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 向左滑动浏览下一张图片</span><br><span class="line">-(void)leftSwipe:(UISwipeGestureRecognizer *)gesture&#123;</span><br><span class="line">    [self transitionAnimation:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 向右滑动浏览上一张图片</span><br><span class="line">-(void)rightSwipe:(UISwipeGestureRecognizer *)gesture&#123;</span><br><span class="line">    [self transitionAnimation:NO];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark 转场动画</span><br><span class="line">-(void)transitionAnimation:(BOOL)isNext&#123;</span><br><span class="line">    //1.创建转场动画对象</span><br><span class="line">    CATransition *transition=[[CATransition alloc]init];</span><br><span class="line">    </span><br><span class="line">    //2.设置动画类型,注意对于苹果官方没公开的动画类型只能使用字符串，并没有对应的常量定义</span><br><span class="line">    transition.type=@&quot;cube&quot;;</span><br><span class="line">    </span><br><span class="line">    //设置子类型</span><br><span class="line">    if (isNext) &#123;</span><br><span class="line">        transition.subtype=kCATransitionFromRight;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        transition.subtype=kCATransitionFromLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置动画时常</span><br><span class="line">    transition.duration=1.0f;</span><br><span class="line">    </span><br><span class="line">    //3.设置转场后的新视图添加转场动画</span><br><span class="line">    _imageView.image=[self getImage:isNext];</span><br><span class="line">    [_imageView.layer addAnimation:transition forKey:@&quot;KCTransitionAnimation&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 取得当前图片</span><br><span class="line">-(UIImage *)getImage:(BOOL)isNext&#123;</span><br><span class="line">    if (isNext) &#123;</span><br><span class="line">        _currentIndex=(_currentIndex+1)%IMAGE_COUNT;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        _currentIndex=(_currentIndex-1+IMAGE_COUNT)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *imageName=[NSString stringWithFormat:@&quot;%i.jpg&quot;,_currentIndex];</span><br><span class="line">    return [UIImage imageNamed:imageName];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-ba1b6c3e258a2592.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>代码十分简单，但是效果和性能却很惊人。当然演示代码有限，其他动画类型大家可以自己实现，效果都很绚丽。</p>
<p>##逐帧动画</p>
<p>前面介绍了核心动画中大部分动画类型，但是做过动画处理的朋友都知道，在动画制作中还有一种动画类型“逐帧动画”。说到逐帧动画相信很多朋友第一个想到的就是UIImageView，通过设置UIImageView的animationImages属性，然后调用它的startAnimating方法去播放这组图片。当然这种方法在某些场景下是可以达到逐帧的动画效果，但是它也存在着很大的性能问题，并且这种方法一旦设置完图片中间的过程就无法控制了。当然，也许有朋友会想到利用iOS的定时器NSTimer定时更新图片来达到逐帧动画的效果。这种方式确实可以解决UIImageView一次性加载大量图片的问题，而且让播放过程可控，唯一的缺点就是定时器方法调用有时可能会因为当前系统执行某种比较占用时间的任务造成动画连续性出现问题。</p>
<p>虽然在核心动画没有直接提供逐帧动画类型，但是却提供了用于完成逐帧动画的相关对象CADisplayLink。CADisplayLink是一个计时器，但是同NSTimer不同的是，CADisplayLink的刷新周期同屏幕完全一致。例如在iOS中屏幕刷新周期是60次/秒，CADisplayLink刷新周期同屏幕刷新一致也是60次/秒，这样一来使用它完成的逐帧动画（又称为“时钟动画”）完全感觉不到动画的停滞情况。</p>
<p>iOS程序在运行后就进入一个消息循环中（这个消息循环称为“主运行循环”），整个程序相当于进入一个死循环中，始终等待用户输入。将CADisplayLink加入到主运行循环队列后，它的时钟周期就和主运行循环保持一致，而主运行循环周期就是屏幕刷新周期。在CADisplayLink加入到主运行循环队列后就会循环调用目标方法，在这个方法中更新视图内容就可以完成逐帧动画。</p>
<p>当然这里不得不强调的是逐帧动画性能势必较低，但是对于一些事物的运动又不得不选择使用逐帧动画，例如人的运动，这是一个高度复杂的运动，基本动画、关键帧动画是不可能解决的。所大家一定要注意在循环方法中尽可能的降低算法复杂度，同时保证循环过程中内存峰值尽可能低。下面以一个鱼的运动为例为大家演示一下逐帧动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define IMAGE_COUNT 10</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    CALayer *_layer;</span><br><span class="line">    int _index;</span><br><span class="line">    NSMutableArray *_images;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景</span><br><span class="line">    self.view.layer.contents=(id)[UIImage imageNamed:@&quot;bg.png&quot;].CGImage;</span><br><span class="line">    </span><br><span class="line">    //创建图像显示图层</span><br><span class="line">    _layer=[[CALayer alloc]init];</span><br><span class="line">    _layer.bounds=CGRectMake(0, 0, 87, 32);</span><br><span class="line">    _layer.position=CGPointMake(160, 284);</span><br><span class="line">    [self.view.layer addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    //由于鱼的图片在循环中会不断创建，而10张鱼的照片相对都很小</span><br><span class="line">    //与其在循环中不断创建UIImage不如直接将10张图片缓存起来</span><br><span class="line">    _images=[NSMutableArray array];</span><br><span class="line">    for (int i=0; i&lt;10; ++i) &#123;</span><br><span class="line">        NSString *imageName=[NSString stringWithFormat:@&quot;fish%i.png&quot;,i];</span><br><span class="line">        UIImage *image=[UIImage imageNamed:imageName];</span><br><span class="line">        [_images addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //定义时钟对象</span><br><span class="line">    CADisplayLink *displayLink=[CADisplayLink displayLinkWithTarget:self selector:@selector(step)];</span><br><span class="line">    //添加时钟对象到主运行循环</span><br><span class="line">    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 每次屏幕刷新就会执行一次此方法(每秒接近60次)</span><br><span class="line">-(void)step&#123;</span><br><span class="line">    //定义一个变量记录执行次数</span><br><span class="line">    static int s=0;</span><br><span class="line">    //每秒执行6次</span><br><span class="line">    if (++s%10==0) &#123;</span><br><span class="line">        UIImage *image=_images[_index];</span><br><span class="line">        _layer.contents=(id)image.CGImage;//更新图片</span><br><span class="line">        _index=(_index+1)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-9e8bf685bb3c9e6a.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>注意：上面仅仅演示了逐帧动画的过程，事实上结合其他动画类型可以让整条鱼游动起来，这里不再赘述。</p>
<p>##UIView动画封装<br>有了前面核心动画的知识，相信大家开发出一般的动画效果应该不在话下。在核心动画开篇也给大家说过，其实UIView本身对于基本动画和关键帧动画、转场动画都有相应的封装，在对动画细节没有特殊要求的情况下使用起来也要简单的多。可以说在日常开发中90%以上的情况使用UIView的动画封装方法都可以搞定，因此在熟悉了核心动画的原理之后还是有必要给大家简单介绍一下UIView中各类动画使用方法的。由于前面核心动画内容已经进行过详细介绍，学习UIView的封装方法根本是小菜一碟，这里对于一些细节就不再赘述了。</p>
<p>##基础动画</p>
<p>基础动画部分和前面的基础动画演示相对应，演示点击屏幕落叶飘落到鼠标点击位置的过程。注意根据前面介绍的隐式动画知识其实非根图层直接设置终点位置不需要使用UIView的动画方法也可以实现动画效果，因此这里落花不再放到图层中而是放到了一个UIImageView中。</p>
<p>下面的代码演示了通过block和静态方法实现动画控制的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    UIImageView *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //设置背景</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    //创建图像显示控件</span><br><span class="line">    _imageView=[[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;petal.png&quot;]];</span><br><span class="line">    _imageView.center=CGPointMake(50, 150);</span><br><span class="line">    [self.view addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 点击事件</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    UITouch *touch=touches.anyObject;</span><br><span class="line">    CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    //方法1：block方式</span><br><span class="line">    /*开始动画，UIView的动画方法执行完后动画会停留在重点位置，而不需要进行任何特殊处理</span><br><span class="line">     duration:执行时间</span><br><span class="line">     delay:延迟时间</span><br><span class="line">     options:动画设置，例如自动恢复、匀速运动等</span><br><span class="line">     completion:动画完成回调方法</span><br><span class="line">     */</span><br><span class="line">//    [UIView animateWithDuration:5.0 delay:0 options:UIViewAnimationOptionCurveLinear animations:^&#123;</span><br><span class="line">//        _imageView.center=location;</span><br><span class="line">//    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">//        NSLog(@&quot;Animation end.&quot;);</span><br><span class="line">//    &#125;];</span><br><span class="line">    </span><br><span class="line">    //方法2：静态方法,较方法1好些</span><br><span class="line">    //开始动画</span><br><span class="line">    [UIView beginAnimations:@&quot;KCBasicAnimation&quot; context:nil];</span><br><span class="line">    [UIView setAnimationDuration:5.0];</span><br><span class="line">    //[UIView setAnimationDelay:1.0];//设置延迟</span><br><span class="line">    //[UIView setAnimationRepeatAutoreverses:NO];//是否回复</span><br><span class="line">    //[UIView setAnimationRepeatCount:10];//重复次数</span><br><span class="line">    //[UIView setAnimationStartDate:(NSDate *)];//设置动画开始运行的时间</span><br><span class="line">    //[UIView setAnimationDelegate:self];//设置代理</span><br><span class="line">    //[UIView setAnimationWillStartSelector:(SEL)];//设置动画开始运动的执行方法</span><br><span class="line">    //[UIView setAnimationDidStopSelector:(SEL)];//设置动画运行结束后的执行方法</span><br><span class="line">    </span><br><span class="line">    _imageView.center=location;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //开始动画</span><br><span class="line">    [UIView commitAnimations];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>补充–弹簧动画效果</p>
<p>由于在iOS开发中弹性动画使用很普遍，所以在iOS7苹果官方直接提供了一个方法用于弹性动画开发，下面简单的演示一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    UIImageView *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //创建图像显示控件</span><br><span class="line">    _imageView=[[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;ball.png&quot;]];</span><br><span class="line">    _imageView.center=CGPointMake(160, 50);</span><br><span class="line">    [self.view addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 点击事件</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    UITouch *touch=touches.anyObject;</span><br><span class="line">    CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    /*创建弹性动画</span><br><span class="line">     damping:阻尼，范围0-1，值越小阻尼越小，阻尼越接近于0，弹性效果越明显</span><br><span class="line">     velocity:弹性复位的速度，越大速度越快</span><br><span class="line">    */</span><br><span class="line">    [UIView animateWithDuration:5.0 delay:0 usingSpringWithDamping:0.1 initialSpringVelocity:1.0 options:UIViewAnimationOptionCurveLinear animations:^&#123;</span><br><span class="line">        _imageView.center=location; //CGPointMake(160, 284);</span><br><span class="line">    &#125; completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2647951-b62d4a6cfeaa9344.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p><strong>补充–动画设置参数</strong></p>
<p>在动画方法中有一个option参数，UIViewAnimationOptions类型，它是一个枚举类型，动画参数分为三类，可以组合使用：</p>
<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>
<blockquote>
<p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。<br>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。<br>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p>
</blockquote>
</li>
<li><p>动画速度控制（可从其中选择一个设置）</p>
<blockquote>
<p>UIViewAnimationOptionCurveEaseInOut：动画开始缓慢，中间快，结束慢。<br>UIViewAnimationOptionCurveEaseIn ：动画开始慢，之后逐渐加速。<br>UIViewAnimationOptionCurveEaseOut：动画开始快，之后逐渐变慢。<br>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</p>
</blockquote>
</li>
<li><p>转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）</p>
<blockquote>
<p>UIViewAnimationOptionTransitionNone：没有转场动画效果。<br>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。<br>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。<br>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。<br>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。<br>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。<br>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</p>
</blockquote>
</li>
</ol>
<p>###关键帧动画</p>
<p>从iOS7开始UIView动画中封装了关键帧动画，下面就来看一下如何使用UIView封装方法进行关键帧动画控制，这里实现前面关键帧动画部分对于落花的控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    UIImageView *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //设置背景</span><br><span class="line">    UIImage *backgroundImage=[UIImage imageNamed:@&quot;background.jpg&quot;];</span><br><span class="line">    self.view.backgroundColor=[UIColor colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    //创建图像显示控件</span><br><span class="line">    _imageView=[[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;petal.png&quot;]];</span><br><span class="line">    _imageView.center=CGPointMake(50, 150);</span><br><span class="line">    [self.view addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    //UITouch *touch=touches.anyObject;</span><br><span class="line">    //CGPoint location= [touch locationInView:self.view];</span><br><span class="line">    </span><br><span class="line">    /*关键帧动画</span><br><span class="line">     options:</span><br><span class="line">     */</span><br><span class="line">    [UIView animateKeyframesWithDuration:5.0 delay:0 options: UIViewKeyframeAnimationOptionCalculationModeLinear animations:^&#123;</span><br><span class="line">        //第二个关键帧（准确的说第一个关键帧是开始位置）:从0秒开始持续50%的时间，也就是5.0*0.5=2.5秒</span><br><span class="line">        [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:0.5 animations:^&#123;</span><br><span class="line">            _imageView.center=CGPointMake(80.0, 220.0);</span><br><span class="line">        &#125;];</span><br><span class="line">        //第三个关键帧，从0.5*5.0秒开始，持续5.0*0.25=1.25秒</span><br><span class="line">        [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.25 animations:^&#123;</span><br><span class="line">            _imageView.center=CGPointMake(45.0, 300.0);</span><br><span class="line">        &#125;];</span><br><span class="line">        //第四个关键帧：从0.75*5.0秒开始，持所需5.0*0.25=1.25秒</span><br><span class="line">        [UIView addKeyframeWithRelativeStartTime:0.75 relativeDuration:0.25 animations:^&#123;</span><br><span class="line">            _imageView.center=CGPointMake(55.0, 400.0);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        NSLog(@&quot;Animation end.&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>补充–动画设置参数</strong></p>
<p>对于关键帧动画也有一些动画参数设置options，UIViewKeyframeAnimationOptions类型，和上面基本动画参数设置有些差别，关键帧动画设置参数分为两类，可以组合使用：</p>
<ol>
<li><p>常规动画属性设置（可以同时选择多个进行设置）</p>
<blockquote>
<p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。<br>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。<br>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。<br>UIViewAnimationOptionRepeat：重复运行动画。<br>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。<br>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p>
</blockquote>
</li>
<li><p>动画模式设置（同前面关键帧动画动画模式一一对应，可以从其中选择一个进行设置）</p>
<blockquote>
<p>UIViewKeyframeAnimationOptionCalculationModeLinear：连续运算模式。<br>UIViewKeyframeAnimationOptionCalculationModeDiscrete ：离散运算模式。<br>UIViewKeyframeAnimationOptionCalculationModePaced：均匀执行运算模式。<br>UIViewKeyframeAnimationOptionCalculationModeCubic：平滑运算模式。<br>UIViewKeyframeAnimationOptionCalculationModeCubicPaced：平滑均匀运算模式。</p>
</blockquote>
</li>
</ol>
<p><strong>注意：前面说过关键帧动画有两种形式，上面演示的是属性值关键帧动画，路径关键帧动画目前UIView还不支持。</strong></p>
<p>###转场动画</p>
<p>从iOS4.0开始，UIView直接封装了转场动画，使用起来同样很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#define IMAGE_COUNT 5</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    UIImageView *_imageView;</span><br><span class="line">    int _currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //定义图片控件</span><br><span class="line">    _imageView=[[UIImageView alloc]init];</span><br><span class="line">    _imageView.frame=[UIScreen mainScreen].bounds;</span><br><span class="line">    _imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">    _imageView.image=[UIImage imageNamed:@&quot;0.jpg&quot;];//默认图片</span><br><span class="line">    [self.view addSubview:_imageView];</span><br><span class="line">    //添加手势</span><br><span class="line">    UISwipeGestureRecognizer *leftSwipeGesture=[[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(leftSwipe:)];</span><br><span class="line">    leftSwipeGesture.direction=UISwipeGestureRecognizerDirectionLeft;</span><br><span class="line">    [self.view addGestureRecognizer:leftSwipeGesture];</span><br><span class="line">    </span><br><span class="line">    UISwipeGestureRecognizer *rightSwipeGesture=[[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(rightSwipe:)];</span><br><span class="line">    rightSwipeGesture.direction=UISwipeGestureRecognizerDirectionRight;</span><br><span class="line">    [self.view addGestureRecognizer:rightSwipeGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 向左滑动浏览下一张图片</span><br><span class="line">-(void)leftSwipe:(UISwipeGestureRecognizer *)gesture&#123;</span><br><span class="line">    [self transitionAnimation:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 向右滑动浏览上一张图片</span><br><span class="line">-(void)rightSwipe:(UISwipeGestureRecognizer *)gesture&#123;</span><br><span class="line">    [self transitionAnimation:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark 转场动画</span><br><span class="line">-(void)transitionAnimation:(BOOL)isNext&#123;</span><br><span class="line">    UIViewAnimationOptions option;</span><br><span class="line">    if (isNext) &#123;</span><br><span class="line">        option=UIViewAnimationOptionCurveLinear|UIViewAnimationOptionTransitionFlipFromRight;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        option=UIViewAnimationOptionCurveLinear|UIViewAnimationOptionTransitionFlipFromLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [UIView transitionWithView:_imageView duration:1.0 options:option animations:^&#123;</span><br><span class="line">        _imageView.image=[self getImage:isNext];</span><br><span class="line">    &#125; completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 取得当前图片</span><br><span class="line">-(UIImage *)getImage:(BOOL)isNext&#123;</span><br><span class="line">    if (isNext) &#123;</span><br><span class="line">        _currentIndex=(_currentIndex+1)%IMAGE_COUNT;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        _currentIndex=(_currentIndex-1+IMAGE_COUNT)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *imageName=[NSString stringWithFormat:@&quot;%i.jpg&quot;,_currentIndex];</span><br><span class="line">    return [UIImage imageNamed:imageName];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的转场动画演示中，其实仅仅有一个视图UIImageView做转场动画，每次转场通过切换UIImageView的内容而已。如果有两个完全不同的视图，并且每个视图布局都很复杂，此时要在这两个视图之间进行转场可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(void)transitionFromView:(UIView*)fromView toView:(UIView*)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0)</span><br></pre></td></tr></table></figure></p>
<p>方法进行两个视图间的转场，需要注意的是默认情况下转出的视图会从父视图移除，转入后重新添加，可以通过UIViewAnimationOptionShowHideTransitionViews参数设置，设置此参数后转出的视图会隐藏（不会移除）转入后再显示。</p>
<p><strong>注意：转场动画设置参数完全同基本动画参数设置；同直接使用转场动画不同的是使用UIView的装饰方法进行转场动画其动画效果较少，因为这里无法直接使用私有API。</strong></p>
<p>上一篇：<a href="http://www.jianshu.com/p/55f49ae46e3d" target="_blank" rel="noopener">iOS开发系列:让你的应用“动”起来–CALayer</a><br>下一篇：<a href="http://www.jianshu.com/p/ed48bd11b5db" target="_blank" rel="noopener">iOS开发之多线程GCD</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS开发系列-让你的应用“动”起来--Core-Animation/" data-id="cjgdiqq79000lkezifd45cuyh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-copy与strong声明属性时的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-copy与strong声明属性时的区别/" class="article-date">
  <time datetime="2018-04-24T08:50:11.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-copy与strong声明属性时的区别/">iOS-copy与strong声明属性时的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>xcode版本：8.3.3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  内存管理</span><br><span class="line">//</span><br><span class="line">//  Created by walg on 2017/8/9.</span><br><span class="line">//  Copyright © 2017年 walg. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;SecondViewController.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableString *strM;</span><br><span class="line">@property (nonatomic, strong) NSString *str;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *strC1;</span><br><span class="line">@property (nonatomic, copy) NSString *strC2;</span><br><span class="line">@property (nonatomic, copy) NSMutableString *strC3;</span><br><span class="line">@property (nonatomic, copy) NSMutableString *strC4;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *strS1;</span><br><span class="line">@property (nonatomic, strong) NSString *strS2;</span><br><span class="line">@property (nonatomic, strong) NSMutableString *strS3;</span><br><span class="line">@property (nonatomic, strong) NSMutableString *strS4;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">//    self.strM = [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">    </span><br><span class="line">    self.strM = [NSMutableString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    self.strC1 = self.strM;</span><br><span class="line">    self.strS1 = self.strM;</span><br><span class="line">    </span><br><span class="line">    self.strC3 = self.strM;</span><br><span class="line">    self.strS3 = self.strM;</span><br><span class="line">    </span><br><span class="line">    self.strC2 =  [NSString stringWithFormat:@&quot;%@&quot;,self.strM];</span><br><span class="line">    self.strS2 =  [NSString stringWithFormat:@&quot;%@&quot;,self.strM];</span><br><span class="line">    </span><br><span class="line">    self.strC4 =  (NSMutableString*)[NSString stringWithFormat:@&quot;%@&quot;,self.strM];</span><br><span class="line">    self.strS4 =  (NSMutableString*)[NSString stringWithFormat:@&quot;%@&quot;,self.strM];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;----------&gt;&gt;&gt;开始&lt;&lt;&lt;----------&quot;);</span><br><span class="line">    NSLog(@&quot;Ori_address-----&gt;&gt;&gt;&gt;&gt;&gt;：value:%@---%p==%p&quot;,_strM,_strM,&amp;_strM);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;C1：value:%@---%p==%p&quot;,_strC1,_strC1,&amp;_strC1);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;S1：value:%@---%p==%p&quot;,_strS1,_strS1,&amp;_strS1);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;C2：value:%@---%p==%p&quot;,_strC2,_strC2,&amp;_strC2);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;S2：value:%@---%p==%p&quot;,_strS2,_strS2,&amp;_strS2);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;C3：value:%@---%p==%p&quot;,_strC3,_strC3,&amp;_strC3);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;S3：value:%@---%p==%p&quot;,_strS3,_strS3,&amp;_strS3);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;C4：value:%@---%p==%p&quot;,_strC4,_strC4,&amp;_strC4);</span><br><span class="line">    NSLog(@&quot;address-----&gt;&gt;&gt;&gt;&gt;&gt;S4：value:%@---%p==%p&quot;,_strS4,_strS4,&amp;_strS4);</span><br><span class="line">    NSLog(@&quot;----------&gt;&gt;&gt;结束&lt;&lt;&lt;----------\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//    self.strM = [_strM stringByAppendingString:@&quot;de&quot;];</span><br><span class="line">    [_strM appendString:@&quot;de&quot;];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;----------&gt;&gt;&gt;点击开始输出&lt;&lt;&lt;----------&quot;);</span><br><span class="line">    NSLog(@&quot;Ori_address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;：value:%@---%p==%p&quot;,_strM,_strM,&amp;_strM);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C1：value:%@---%p==%p&quot;,_strC1,_strC1,&amp;_strC1);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S1：value:%@---%p==%p&quot;,_strS1,_strS1,&amp;_strS1);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C2：value:%@---%p==%p&quot;,_strC2,_strC2,&amp;_strC2);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S2：value:%@---%p==%p&quot;,_strS2,_strS2,&amp;_strS2);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C3：value:%@---%p==%p&quot;,_strC3,_strC3,&amp;_strC3);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S3：value:%@---%p==%p&quot;,_strS3,_strS3,&amp;_strS3);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C4：value:%@---%p==%p&quot;,_strC4,_strC4,&amp;_strC4);</span><br><span class="line">    NSLog(@&quot;address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S4：value:%@---%p==%p&quot;,_strS4,_strS4,&amp;_strS4);</span><br><span class="line">    NSLog(@&quot;----------&gt;&gt;&gt;点击结束输出&lt;&lt;&lt;----------\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>《点了两次》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">2017-08-09 18:17:29.112 内存管理[31855:14351521] ----------&gt;&gt;&gt;开始&lt;&lt;&lt;----------</span><br><span class="line">2017-08-09 18:17:29.112 内存管理[31855:14351521] Ori_address-----&gt;&gt;&gt;&gt;&gt;&gt;：value:abc---0x60800026ba40==0x7f86d0421748</span><br><span class="line">2017-08-09 18:17:29.112 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;C1：value:abc---0xa000000006362613==0x7f86d0421758</span><br><span class="line">2017-08-09 18:17:29.113 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;S1：value:abc---0x60800026ba40==0x7f86d0421778</span><br><span class="line">2017-08-09 18:17:29.113 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;C2：value:abc---0xa000000006362613==0x7f86d0421760</span><br><span class="line">2017-08-09 18:17:29.113 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;S2：value:abc---0xa000000006362613==0x7f86d0421780</span><br><span class="line">2017-08-09 18:17:29.113 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;C3：value:abc---0xa000000006362613==0x7f86d0421768</span><br><span class="line">2017-08-09 18:17:29.113 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;S3：value:abc---0x60800026ba40==0x7f86d0421788</span><br><span class="line">2017-08-09 18:17:29.113 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;C4：value:abc---0xa000000006362613==0x7f86d0421770</span><br><span class="line">2017-08-09 18:17:29.114 内存管理[31855:14351521] address-----&gt;&gt;&gt;&gt;&gt;&gt;S4：value:abc---0xa000000006362613==0x7f86d0421790</span><br><span class="line">2017-08-09 18:17:29.114 内存管理[31855:14351521] ----------&gt;&gt;&gt;结束&lt;&lt;&lt;----------</span><br><span class="line">2017-08-09 18:19:13.818 内存管理[31855:14351521] ----------&gt;&gt;&gt;点击开始输出&lt;&lt;&lt;----------</span><br><span class="line">2017-08-09 18:19:13.819 内存管理[31855:14351521] Ori_address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;：value:abcde---0x60800026ba40==0x7f86d0421748</span><br><span class="line">2017-08-09 18:19:13.820 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C1：value:abc---0xa000000006362613==0x7f86d0421758</span><br><span class="line">2017-08-09 18:19:13.820 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S1：value:abcde---0x60800026ba40==0x7f86d0421778</span><br><span class="line">2017-08-09 18:19:13.820 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C2：value:abc---0xa000000006362613==0x7f86d0421760</span><br><span class="line">2017-08-09 18:19:13.820 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S2：value:abc---0xa000000006362613==0x7f86d0421780</span><br><span class="line">2017-08-09 18:19:13.820 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C3：value:abc---0xa000000006362613==0x7f86d0421768</span><br><span class="line">2017-08-09 18:19:13.820 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S3：value:abcde---0x60800026ba40==0x7f86d0421788</span><br><span class="line">2017-08-09 18:19:13.821 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C4：value:abc---0xa000000006362613==0x7f86d0421770</span><br><span class="line">2017-08-09 18:19:13.845 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S4：value:abc---0xa000000006362613==0x7f86d0421790</span><br><span class="line">2017-08-09 18:19:13.845 内存管理[31855:14351521] ----------&gt;&gt;&gt;点击结束输出&lt;&lt;&lt;----------</span><br><span class="line">2017-08-09 18:19:19.625 内存管理[31855:14351521] ----------&gt;&gt;&gt;点击开始输出&lt;&lt;&lt;----------</span><br><span class="line">2017-08-09 18:19:19.626 内存管理[31855:14351521] Ori_address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;：value:abcdede---0x60800026ba40==0x7f86d0421748</span><br><span class="line">2017-08-09 18:19:19.626 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C1：value:abc---0xa000000006362613==0x7f86d0421758</span><br><span class="line">2017-08-09 18:19:19.626 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S1：value:abcdede---0x60800026ba40==0x7f86d0421778</span><br><span class="line">2017-08-09 18:19:19.626 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C2：value:abc---0xa000000006362613==0x7f86d0421760</span><br><span class="line">2017-08-09 18:19:19.626 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S2：value:abc---0xa000000006362613==0x7f86d0421780</span><br><span class="line">2017-08-09 18:19:19.627 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C3：value:abc---0xa000000006362613==0x7f86d0421768</span><br><span class="line">2017-08-09 18:19:19.627 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S3：value:abcdede---0x60800026ba40==0x7f86d0421788</span><br><span class="line">2017-08-09 18:19:19.627 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;C4：value:abc---0xa000000006362613==0x7f86d0421770</span><br><span class="line">2017-08-09 18:19:19.628 内存管理[31855:14351521] address&lt;&lt;&lt;&lt;&lt;&lt;-----&gt;&gt;&gt;&gt;&gt;&gt;S4：value:abc---0xa000000006362613==0x7f86d0421790</span><br><span class="line">2017-08-09 18:19:19.628 内存管理[31855:14351521] ----------&gt;&gt;&gt;点击结束输出&lt;&lt;&lt;----------</span><br></pre></td></tr></table></figure></p>
<p><strong>可以看到：</strong><br><strong>一、在接收NSMutableString的值时：</strong><br>（1）@property (nonatomic, strong) NSString <em>strS2; 用“=”赋值时，_strS2 与_strC3的值指向同一内存地址。当_strC3改变时，_strS2也跟着改变。<br>（2）@property (nonatomic, copy) NSString </em>strC2; 用“=”赋值时，_strC2 与_strC3的值指向新的内存地址。当_strC3改变时，_strC2不跟着改变。<br>（3）[NSString stringWithFormat:@”%@”,self.strC3]当用这种方式赋值时，无论是copy还是strong都会开辟新的地址，与原来的都没有关联。<br>（4）以上跟NSMutableString还是NSString无关。<br>二、在接收NSString的值时，都是开辟新的地址。互不影响，与copy和strong无关！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-copy与strong声明属性时的区别/" data-id="cjgdiqq6y0008keziy8lzaneq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-App图标和启动画面尺寸" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/iOS-App图标和启动画面尺寸/" class="article-date">
  <time datetime="2018-04-24T08:50:11.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/iOS-App图标和启动画面尺寸/">iOS-App图标和启动画面尺寸</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iphone平台一般要求3种规格的图片：1x、2x、3x，也是就Icon.png、<a href="mailto:Icon@2x.png" target="_blank" rel="noopener">Icon@2x.png</a>、<a href="mailto:Icon@3x.png" target="_blank" rel="noopener">Icon@3x.png</a>.</p>
<p><strong>注意：<a href="http://lib.csdn.net/base/ios" target="_blank" rel="noopener">iOS</a>所有图标的圆角效果由系统生成，给到的图标本身不能是圆角的。</strong></p>
<ol>
<li><p>桌面图标 (app icon)<br>for iPhone6 plus(@3x) : 180 x 180<br>for iPhone 6/5s/5/4s/4(@2x) : 120 x 120</p>
</li>
<li><p>系统搜索框图标 (Spotlight search results icon)<br>for iPhone6 plus(@3x) : 120 x 120<br>for iPhone6/5s/5/4s/4(@2x) : 80 x 80</p>
</li>
<li><p>系统设置图标 (Settings icon)<br>for iPhone6 plus(@3x) : 87 x 87<br>for iPhone6/5s/5/4s/4(@2x) : 58 x 58</p>
</li>
<li><p>启动图片 (launch image)<br>for iPhoen5s/5(@2x) : 640 x 1136<br>for iPhoen4s/4(@2x) : 640 x 960<br>iPhone6/iPhone6 plus 建议使用 launch file 或 storyboard ；如果依然想使用图片，尺寸数值为：</p>
</li>
</ol>
<p>for iPhone 6(@2x) : 750 x 1334</p>
<p>for iPhone 6 plus (@3x) : 1242 x 2208</p>
<ol start="5">
<li>另一种根据iOS系统的分类法<br><strong>Spotlight</strong><br>iOS 5,6<br>base: 29pt, 需要 @1x, @2x, @3x，得出：29 x 29, 58 x 58, 87 x 87</li>
</ol>
<p>iOS 7,8<br>base: 40pt, 需要 @2x, @3x，得出：80 x 80, 120 x 120</p>
<p><strong>iPhone App</strong><br>iOS 5,6<br>base: 57pt，需要 @1x, @2x, 得出：57 x 57, 114 x 114</p>
<p>iOS 7,8<br>base: 60pt，需要 @2x, @3x，得出：120 x 120, 180 x 180</p>
<p><strong>Settings</strong><br>iOS 5,6,7,8<br>base: 29pt，需要 @1x,@2x,@3x，得出：29 x 29, 58x58, 87x87</p>
<ol start="6">
<li>尺寸总结：<br><strong>图标尺寸输出列表：</strong><br>180x180<br>120x120<br>87x87<br>80x80<br>58x58<br>57x57<br>29x29</li>
</ol>
<p><strong>启动图片尺寸输出列表：</strong><br>640x960<br>640x1136<br>750x1334<br>1242x2208</p>
<ol start="7">
<li>参考文献<br><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/IconMatrix.html#//apple_ref/doc/uid/TP40006556-CH27" target="_blank" rel="noopener">Icon and Image Sizes</a><br><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/LaunchImages.html#//apple_ref/doc/uid/TP40006556-CH22-SW1" target="_blank" rel="noopener">Launch Images</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/iOS-App图标和启动画面尺寸/" data-id="cjgdiqq6v0004kezi2qikhud6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/24/hello-world/" class="article-date">
  <time datetime="2018-04-24T08:27:09.000Z" itemprop="datePublished">2018-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/24/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/24/hello-world/" data-id="cjgdiqq6u0003kezioqevmbeo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/24/iOS-开发中手势方法的使用/">iOS-开发中手势方法的使用</a>
          </li>
        
          <li>
            <a href="/2018/04/24/C指针--函数形参int-p与int--p的区别/">C指针--函数形参int-p与int--p的区别</a>
          </li>
        
          <li>
            <a href="/2018/04/24/KVO键值依赖/">KVO键值依赖</a>
          </li>
        
          <li>
            <a href="/2018/04/24/iOS开发过程中遇到的新奇玩意儿/">iOS开发过程中遇到的新奇玩意儿</a>
          </li>
        
          <li>
            <a href="/2018/04/24/iOS开发证书要点详解，ios证书详解/">iOS开发证书要点详解，ios证书详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Kasign<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>